---
layout: post
title: "[운영체제] 쓰레드의 이해"
subtitle: "[운영체제] 쓰레드의 이해"
categories: CS
tags: OS  
comments: true


---

## 1. Thread

- Light Weight Process라고도 함
- Process 간에는 각 process의 데이터 접근이 불가하다(IPC를 이용해야함).
- 그러나 스레드는
  - 하나의 프로세스에 여러개의 스레드 생성이 가능하다. 
  - 여러 스레드들이 동시에 실행 가능
  - 프로세스가 여러개의 스레드로 된 것이므로 프로세스의 데이터를 모두 접근 가능하다. (IPC를 사용할 필요가 없음)

## 2. Thread의 동작 방식

![스레드1](https://yunsikus.github.io/assets/img/post_img/스레드1.jpg)

- 쓰레드는 각각의 Stack 영역을 가지는 함수처럼 생각하면 된다. 
- 각 쓰레드를 위한 Stack Pointer와 Program Counter도 있다. 
- 각 쓰레드는 stack 영역만 별도의 stack 영역으로 분리해서 사용하고 Heap, BSS, DATA, CODE는 모두 공유한다.
- 이렇게 **하나의 프로세스 내에서 생성된 thread 끼리 해당 프로세스의 영역을 공유한다**는 특징이 있다. 

![스레드2](https://yunsikus.github.io/assets/img/post_img/스레드2.jpg)

## 3. 멀티태스킹과 멀티프로세싱

![스레드3](https://yunsikus.github.io/assets/img/post_img/스레드3.jpg)
스
- 멀티 태스킹은, 멀티 프로세스가 있을 떄, 짧은 시간마다 CPU에서 실행되는 Process를 바꿔가면서 실행시켜서 사용자에겐 이 multi process들이 동시에 실행되는 것처럼 보인다. 

- 멀티 프로세싱은 여러개의 프로세스를 여러개의 CPU에서 병렬로 실행시키는것. 하나의 프로세스라고 보면, 쓰레드를 여러개 만들어서 여러개의 CPU에서 실행시켜도 된다. 

## 4. 쓰레드의 장점
### 1. 사용자에 대한 응답성 향상
- A기능을 thread1, B기능을 thread2로 나눠서 생각하면 멀티 태스킹이나 멀티 프로세싱으로 동시처리가 가능해진다. 그러면 응답시간이 짧아질 수 있다. 
  
![스레드4](https://yunsikus.github.io/assets/img/post_img/스레드4.jpg)

### 2. 자원 공유의 효율성
- thread는 하나의 프로세스 내에서 자원 공유가 가능하기 때문에 프로세스의 데이터를 모두 접근 가능하다. 
- 각각의 프로세스로 나뉘어져 있다면 IPC기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요없다. 
- 만약 동시 실행을 위해 6개의 프로세스를 만들었다면 6개의 프로세스 공간이 필요해진다. (하나의 프로세스 4G라면 24G)
- 그런데 하나의 프로세스당 6개의 쓰레드를 만들면 4G만 있으면 된다. (저원 효율성)

### 3. 작업이 분리되어 코드가 간결해진다. But 코드를 어떻게 작성하느냐에 따라 달라지는 문제이긴 함. 

## 5. 쓰레드의 단점

### 1. 스레드중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받음
- 쓰레드는 하나의 프로세스 안에서 작동하기 때문에, thread중 한 thread만 문제가 생겨도 전체 프로세스가 영향을 받는다. 

![스레드5](https://yunsikus.github.io/assets/img/post_img/스레드5.jpg)

### 2. thread를 많이 생성하면, Context Switching이 많이 일어나 성능이 저하된다. 
- Linux OS에서는 Thread를 Process와 거의 동일하게 다룬다. 그래서 thread 역시 많이 생성하면 모든 Thread를 스케줄링 해야하므로 Context Switching이 빈번할 수 밖에 없다. 

## 6. Thread의 동기화 이슈
- 동기화란 작업들 사이에 실행시기를 맞추는 것. 
- 여러 스레드가 동일한 자원 접근 시 동기화 이슈 발생
  - 동일 자원을 여러 스레드가 동시 수정 시, 각 스레드 결과에 영향을 줌

```python
#python code

import threading #쓰레드를 지원하는 라이브러리

q_count = 0

def thread_main():
    global g_count
    # lock.acquire()  -> Context Switching 방지
    for i in range(10000):
    	g_count = g_count + 1
    # lock.release() -> 이후부터 Context Switching 가능해짐
        
threads = []

for i in range(50):
    th = threading.Thread(target = thread_main) #쓰레드로 실행할 함수명을 target에 넣어주어서 해당 함수를 쓰레드로 만들어서 실행시킨다. 
    threads.append(th)
    
for th in threads: # 쓰레드 함수 실행
	th.start()
    
for th in threads: # 모든 쓰레드 작업 끝나는 시간을 맞추기 위해
	th.join()
    
print('g_count = ', g_count) #실행 결과 g_count = 500000
```
- range가 100000이상 증가할 경우 g_count가 비정상 값으로 나오게 된다. 그 이유는?

![스레드6](https://yunsikus.github.io/assets/img/post_img/스레드6.jpg)

- thread1에서 `g_count`가 저장되기 전에 thread2로 context_switching이 일어나면 g_count가 잘못 전해진다. 
- 각 thread가 실행되는동안 context_switching이 일어나지 않도록 방지하는 장치를 넣어 해결할 수 있다.  
- `lock.acquire()`로 인해 context_switching이 일어나지 않는다. 
- `lock.release()` 후부터 context_switching이 가능해진다. 

## 7. Thread의 동기화 이슈 해결방법
- 해결 방법이면서, 임계영역을 프로세스들이 같이 쓸 수 있는 전제 조건이 된다. 
- **Mutual Exclusion**
  - 여러 스레드가 변경하는 공통으로 사용하는 변수에 대하서 Exclusive Access를 통해 어느 한 스레드가 해당 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막는 것이 필요
  - 이를 코드로 보면

![스레드7](https://yunsikus.github.io/assets/img/post_img/스레드7.jpg)

- Progress
  - 아무도 critical section에 있지 않은 상태에서 critical section에 들어가고자 하는 프로세스가 있으면 critical section에 들어가게 해주어야 한다. 
  
- Bounded Waiting
  - 프로세스가 critical section에 들어가려고 요청한 후부터 그 요청이 허용될때까지 다른 프로세스들이 critical section에 들어가는 횟수에 제한이 있어야 한다. (무한히 기다려야 하는게 아니라 끝이 있어야 한다. )

## 8. Deadlock & Starvation

- `Deadlock`은 여러 프로세스가 동일 자원 점유를 요청할 때 발생하고, `Starvation`은 여러 프로세스가 부족한 자원을 점유하기 위해 경쟁할 때, 특정 프로세스는 영원히 자우너 할당이 안되는 경우를 의미. 

- Deadlock
  - 무한 대기 상태. 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에, 다음 단계로 진행하지 못하는 상태. 

![스레드8](https://yunsikus.github.io/assets/img/post_img/스레드8.jpg)

  - 다음 4가지 조건이 모두 성립될 때 데드락이 발생할 가능성이 있다. 
    - **Mutual exclusion(상호 배제)**: 매 순간 하나의 프로세스만이 독점적으로 자원을 사용할 수 있다 
    - **No Preemption(비선점)**: 프로세스는 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않는다. 
    - **Hold and wait(점유 대기)**: 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있다. 
    - **Circulat wait(순환 대기)**: 자원을 기다리는 프로세스간에 사이클이 형성되어야 한다.
  - 해결방법은 위의 4가지 조건 중 하나를 제거

- Starvation
  - 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당받지 못하는 상태
  - 해결방법은 오래 기다린 프로세스의 우선 순위를 높여주거나, FIFO기반의 요청큐를 사용하는 방법이 있다.

<details>
<summary>쓰레드는 무엇이고 쓰레드의 특징은?</summary>
<div markdown="1">       
스레드는 CPU 사용의 기본단위. 프로세스 내에서 실행되는 여러 흐름의 단위
스레드는 프로세스 내에서 생성된 스레드끼리 해당 프로세스의 영역을 공유한다. 
여러개의 스레드로 동시 처리가 가능해져 사용자에 대한 응답성이 향상된다.
But 쓰레드는 하나의 프로세스 안에서 작동하기 때문에, thread중 한 thread만 문제가 생겨도 전체 프로세스가 영향을 받는다. 
쓰레드를 많이 생성하면 Context Switching이 많이 일어나 성능이 저하된다. 

</div>
</details>

<details>
<summary>프로세스와 스레드의 차이는?</summary>
<div markdown="1">       
프로세스는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램. 즉 메모리에 올라와 실행되고 있는 독립적인 프로그램 인스턴스. 쓰레드는 프로세스 내에서 동작되는 여러 실행의 흐름 단위. 
프로세스와 달리 스레드는 코드, 데이터, 힙 영역을 통해 프로세스 자원을 공유할 수 있다. 
프로세스와 달리 스레드는 자원을 공유하기 때문에 한 스레드에서 오류가 발생하면 같은 프로세스 내의 스레드 모두가 종료됨. 

</div>
</details>

<details>
<summary>스택을 스레드마다 독립적으로 할당하는 이유?</summary>
<div markdown="1">       
각 스레드가 독립적인 실행 흐름을 갖기 위해서는 독립적인 함수 호출이 보장되어야 하기 때문. 

</div>
</details>

<details>
<summary>스레드와 멀티스레드의 차이에 대하여 설명하고, 멀티 스레드의 장단점을 설명해보세요</summary>
<div markdown="1">       
**스레드** : 할당 받은 자원을 이용한 프로세스의 실행 흐름의 단위이다.
**멀티** 스레드 : 한 프로세스 내에서 이러한 스레드가 여러 개 동작하는 방식을 의미한다.

멀티스레드의 장점 : 프로세스를 여러개 두는 방식에 비해 컨텍스트 스위칭 비용이 적게 들며 응답 시간이 빠르다는 장점이 있다.

멀티스레드의 단점 : 같은 프로세스 내의 자원을 다른 스레드들과 공유하므로 동기화 문제를 고려해야 한다. 또한 프로세스가 종료되면 내부 스레드들 역시 모두 종료되므로 한 스레드가 프로세스를 의도치 않게 종료했을 경우 나머지 스레드들도 모두 종료될 수 있다는 단점이 있다. 또한, 여러 스레드가 동일한 자원 접근 시 동기화 이슈 발생.
</div>
</details>

<details>
<summary>멀티 스레드와 멀티 프로세스의 차이는?</summary>
<div markdown="1">       
멀티 스레드 : 적은 메모리 공간 차지, context switch 빠름. 하지만 동기화 문제가 있고 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있음.
멀티 프로세스 : 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않음. 하지만 많은 메모리 공간을 차지하고 CPU 점유 시간을 많이 차지함.
</div>
</details>

<details>
<summary>임계 영역을 프로세스들이 같이 쓸 수 있는 전제 조건을 설명해주세요</summary>
<div markdown="1">       
임계 영역을 프로세스들이 같이 쓸 수 있는 전제 조건으로는 Mutual Exclusion, Progress, Bounded Waiting 3가지가 있습니다.

상호 배제 (Mutual Exclusion) : 어떤 task가 임계 영역을 사용 중이면 다른 task는 사용이 불가능합니다.
진행 (Progress) : 현재 임계 영역을 사용 중인 task가 없고, 들어가길 원하는 task가 있다면 바로 들여보냅니다.
한정된 대기 (Bounded Waiting) : 프로세스가 진입 가능한 횟수에는 제한이 있어서 특정한 한 프로세스만 계속 진입하는 것을 방지합니다.

</div>
</details>

<details>
<summary>Thread-safe란?</summary>
<div markdown="1">       
멀티 스레드 환경에서 여러 스레드가 동시에 공유 자원에 접근할 때, 의도한대로 동작하는 것을 말합니다. Thread-safe하기 위해서는 공유 자원에 접근하는 임계 영역을 Mutex, Semaphore 등의 동기화 기법으로 제어해줘야 합니다.
</div>
</details>

