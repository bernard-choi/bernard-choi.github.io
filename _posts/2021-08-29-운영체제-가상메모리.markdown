---
layout: post
title: "[운영체제] 가상메모리의 이해"
subtitle: "[운영체제] 가상메모리의 이해"
categories: CS
tags: OS  
comments: true


---
## 가상 메모리(Virtual Memory)

- 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음
    - 리눅스는 하나의 프로세스가 4GB지만 특정 프로세스에서 참조하는 메모리는 제한적
        - ex: 리눅스 기준 한 프로세스 : 4GB, 그런데 내 컴퓨터는 16GB → 프로세스 4개 밖에 못돌리나??
    - 어떻게 하면 여러개의 프로세스들 실행할 때 메모리 크기의 한계를 극복할 수 있을까? 에서 탄생한 기술이 가상 메모리 기술
    - 메모리 접근은 순차적이고 지역화되어 있다는 특성 때문에 실제 필요한 메모리는 훨씬 적음. 실제 필요한 메모리만 물리 주소에 올린다. 
- 가상 메모리 적용 vs 미적용
  
![virtualmemory0](https://yunsikus.github.io/assets/img/post_img/가상메모리1.jpg)

- 미적용시, 한 프로세스가 메모리 공간을 많이 차지하여여러 프로세스를 한 메모리에서 사용하기 
힘들다.

- fragmentation (외부 단편화 문제)가 존재해 여러 프로세스의 실행이 힘들다.

- 가상 메모리의 기본 아이디어
    - 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소를 바꿔주면 된다. 
    - `virtual address(가상 주소)` : 프로세스가 참조하는 주소 (0~4G)
    - `physical address(물리 주소)` : 실제 메모리 주소 (0~4G중 일부분만 메모리에 올라감)
    - `MMU(Memory Management Unit)`
        - CPU에 코드 실행 시, 가상 주소 메모리 접근이 필요할 떄, 해당 주소를 물리 주소값으로 변환해주는 하드웨어 장치

![virtualmemory2](https://yunsikus.github.io/assets/img/post_img/virtualmemory2.jpg)

## 페이징 시스템

- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
- 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용
- `page`: 가상 주소 공간의 최소 단위. 리눅스의 경우 4KB로 paging
- `paging table` : 프로세스의 PCB에 Page Table 구조체를 가리키는 주소가 있는데, 이 Page Table에는 물리 메모리에 있는 page frame 번호와 해당 페이지의 첫 물리 주소 정보를 매칭한 표.
- 
![virtualmemory3](https://yunsikus.github.io/assets/img/post_img/virtualmemory3.jpg)

## 페이징 주소 표현 방법
- 가상주소 v = (p,d)로 표현한다. 
- `p`: 가상 메모리의 page 번호
- `d`: p와 매칭되는 물리주소와의 오프셋 (displacement=변위)

paging system에서 해당 프로세스에서 특정 가상 주소를 가지고 어떤 데이터에 접근하고자 하면,

1) page table에 해당 가상 주소와 그 page 번호가 있는지 확인
   
2) page 번호가 있으면 이와 매칭된 첫 물리 주소(p')를 알아낸다.

![virtualmemory4](https://yunsikus.github.io/assets/img/post_img/virtualmemory4.jpg)

### 1) 다중 단계 페이징 시스템

- 4GB의 프로세스를 모두 페이지로 나눠 메모리에 올리는것은 공간 낭비. 
- 페이지 정보를 단계를 나누어 디렉토리 개념을 필요한 부분만 쓰는 방법

![virtualmemory5](https://yunsikus.github.io/assets/img/post_img/virtualmemory5.jpg)

### 2) 페이징 시스템과 공유 메모리
- 프로세스마다 커널의 영역 1GB를 가지고 있는데, 그 공간은 실제 메모리에 다 따로 할당되는게 아닌 프로세스간 동일한 물리주소를 가리키게 함. (공간 절약, 메모리 할당 시간 절약)

![virtualmemory6](https://yunsikus.github.io/assets/img/post_img/virtualmemory6.jpg)

## MMU와 TLB
- MMU는 CPU에 코드 실행 시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 물리 주소 값으로 변환해주는 하드웨어 장치. 매번 MMU가 물리 주소를 확인하기 위해 아래 그림과 같이 메모리를 갔다와야 하는데 이 과정을 캐싱처리를 통해 더 효율적으로 할 수 있다. 

![virtualmemory7](https://yunsikus.github.io/assets/img/post_img/virtualmemory7.jpg)

## Demand Paging

위와 같은 paging system을 사용하면 프로세스에서 나눠진 page를 언제 물리 메모리에 올려놓을지에 대한 정책이 필요. 선행 페이징으로 하면 그냥 프로세스를 실행하자마자 page 먼저 다 올려두는 것인데 이것보다 실제로 필요할 때 page를 메모리에 올리는 것이 좋을 것. 이게 demand paging. 

- `Demand Paging` : 프로세스의 모든 데이터를 메모리로 적재하지 않고 실행 중 필요한 시점에만 메모리로 적재
- `Invalid` : 사용되지 않는 주소 영역. 페이지가 물리적 메모리에 없는 경우(valid는 반대)
- `page fault` : 어떤 페이지가 물리 메모리에 없을 떄 발생하는 인터럽트로 page fault가 발생하면 운영체제가 해당 페이지에 올려준다. 

![virtualmemory8](https://yunsikus.github.io/assets/img/post_img/virtualmemory8.jpg)

## 페이지 교체 정책

- 운영체제가 특정 페이지를 물리 메모리에 올리려고 하는데 물리 메모리가 다 차있으면, 기존 페이지중 하나를 물리 메모리에서 저장 매체로 내리고 새로운 페이지를 해당 물리 메모리 공간에 올려야 한다. 이때 어떤 페이지를 물리 메모리에서 저장 매체로 내릴 것인가에 대한 것이 페이지 교체 정책

- 페이지 교체 흐름은 다음과 같다. 
    - 1) 디스크에서 필요한 페이지의 위치를 찾는다. 
    - 2) 빈 페이지 프레임을 찾는다. 
      - i) 페이지 교체알고리즘을 통해 희생될 페이지를 고른다. 
      - ii) 희생될 페이지를 디스크에 기록하고 관련 페이지 테이블을 수정한다. 
    - 3) 새롭게 비워진 페이지 테이블 내 새 페이지를 읽어오고, 프레임 테이블을 수정
    - 4) 사용자 프로세스 재시작

1) `FIFO`
    - 가장 먼저 들어온 페이지를 내린다. 
    - 장점
        - 이해하기 쉽고, 프로그래밍도 쉽다. 
    - 단점
        - 오래된 페이지가 불필요한 정보를 포함한다고 보장할 수 없다. 
        - 처음부터 활발하게 사용되는 페이지를 교체해서 페이지 부재율을 높일 수 있다. 
        - Belady의 모순: 페이지를 저장할 수 있는 페이지 프레임 개수를 늘려도 되려 페이지 부재가 더 많이 발생한다는 모순이 존재한다. 

2) `OPT(Optimal) 알고리즘`
    - 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다.
    - 장점
        - 가장 낮은 페이지 부재율을 보장한다. 
    - 단점
        - 구현이 어렵다. 모든 프로세스의 메모리 참조 계획을 미리 파악할 수 없기 때문

3) `LRU(Least Recently Used) 알고리즘`
    - 가장 오래전에 사용된 페이지를 내리는 것


4) `LFU(Least Frequently Used) 알고리즘`
    - 가장 적게 사용된 페이지를 내리는 것
    - 어떤 프로세스가 특정 페이지를 집중적으로 사용하다가 다른 기능을 사용하게 되면 더이상 사용하지 않아도 계속 메모리에 머물게 되어 초기 가정에 어긋날 수 있다. 

5) `NUR 알고리즘`
    - LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 내리자는 알고리즘. 각 페이지마다 참조 여부를 나타내는 비트(R), 수정 여부를 나타내는 비트(M) 을 두어서 (0,0) (0,1) (1,0) (1,1) 순으로 교체한다. 


## 세그맨테이션
- 페이징 시스템이 가상 메모리를 같은 크기의 블록으로 분할한다면, 세그맨테이션에서는 서로 크기가 다른 논리적 단위인 세그먼트로 분할

- 페이징 기법은 내부 단편화 문제가 발생
    - 페이지 블록만큼 데이터가 딱 맞게 채워져있지 않을 때 공간낭비

- 세그맨테이션 기법은 외부 단편화 문제가 발생
     - 물리 메모리가 원하는 연속된 크기의 메모리를 제공해주지 못하는 경우

<details>
<summary>가상 메모리를 사용 해야하는 이유?</summary>
<div markdown="1">       
프로세스에 존재하는 메모리가 무한하지 않기 때문에 가상메모리를 사용하여야 한다. 메모리가 부족하여 일어나는 예기치 않은 오류들을 가상메모리를 사용함으로써 일어나지 않고 정상적으로 프로세스가 진행할 수 있도록 도와준다.
</div>
</details>

<details>
<summary>가상메모리를 효율적으로 관리하는 방법에는 어떤 것들이 있을까요?</summary>
<div markdown="1">       
대표적으로 두가지 Paging : 고정된 영역인 페이지로 분할 , Segmentation : 가변적인 영역인 세그먼트로 분할이 있다.
</div>
</details>

<details>
<summary>메모리에 적재된 페이지 중 사용하려는 페이지가 없는 현상을 무엇이라고 할까요?</summary>
<div markdown="1">       
Page fault
</div>
</details>

<details>
<summary>페이지를 교체하는 다양한 방법들에 대해 알려주세요.</summary>
<div markdown="1">       
FIFO : 먼저 메모리에 들어온 페이지 순서대로 교체한다.
OPR : 앞으로 가장 오랫동안 사용되지 않을 페이지를 찾아 교체한다.
LRU : 가장 오랫동안 사용되지 않은 페이지를 선택하여 교체한다.
LFU : 참조 횟수가 가장 적은 페이지를 교체한다.
MFU : 참조 회수가 가장 많은 페이지를 교체한다.
</div>
</details>

## Reference

[https://libertegrace.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4](https://libertegrace.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EC%9D%B4%ED%95%B4)