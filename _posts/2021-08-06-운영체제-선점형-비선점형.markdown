---
layout: post
title: "[운영체제] 선점형/비선점형 스케줄러"
subtitle: "[운영체제] 선점형/비선점형 스케줄러"
categories: CS
tags: OS  
comments: true


---

## 비선점형 스케줄러(Non-preemtive Scheduling)

하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음
예를 들어, CPU에 있는 A 프로세스의 상태가 자체적으로 block되거나, terminated 되어야만 그제서야 B 프로세서가 실행 시킬 수 있다. 즉 스케줄러가 CPU에 있는 프로세스를 선점, 제어할 수 없다. 

그림으로 비선점형 스케줄러가 작동하는 방식을 보면, 

![비선점형1](https://yunsikus.github.io/assets/img/post_img/비선점형1.jpg)

![비선점형2](https://yunsikus.github.io/assets/img/post_img/비선점형2.jpg)

![비선점형3](https://yunsikus.github.io/assets/img/post_img/비선점형3.jpg)

![비선점형4](https://yunsikus.github.io/assets/img/post_img/비선점형4.jpg)

![비선점형5](https://yunsikus.github.io/assets/img/post_img/비선점형5.jpg)

## 선점형 스케줄러(Preemptive Scheduling)

하나의 프로세스가 다른 프로세스 대신에 프로세서를 차지할 수 있음. 즉 프로세스 상태가 running 중에도 스케줄러가 이를 중단시키고 다른 프로세스로 교체할 수 있다. 

예를 들어, 시분할 시스템같은 경우, CPU에 있는 A프로세스가 실행된 일정 시간이 지나면 스케줄러가 이를 선점하여 ready 상태로 변화시키고 B프로세스가 실행될 수 있게 한다. 

선점형 스케줄러인 경우는 위의 비선점형일 때와 진행이 어떻게 되는지 보자. 

![선점형1](https://yunsikus.github.io/assets/img/post_img/선점형1.jpg)

![선점형2](https://yunsikus.github.io/assets/img/post_img/선점형2.jpg)

![선점형3](https://yunsikus.github.io/assets/img/post_img/선점형3.jpg)

<details>
<summary>선점 스케줄링과 비선점 스케줄링의 차이점은?</summary>
<div markdown="1">       

선점 스케줄링은 높은 우선순위의 프로세스가 들어올 경우 현재 프로세스를 중지시키고, 높은 우선순위의 프로세스를 처리.
비선점 스케줄링은 한번 할당하면 끝날때까지 다른 프로세스가 들어오지 못하는 스케줄링
엄격한 비선점식 스케줄링을 사용하지 않는 이유는 짧은 프로세서가 오랫동안 대기하게 될 경우 비효율적이고, 기아상태가 발생할 수 있다. 

</div>
</details>

Reference

[https://libertegrace.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%A0%EC%A0%90%ED%98%95%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC](https://libertegrace.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%84%A0%EC%A0%90%ED%98%95%EB%B9%84%EC%84%A0%EC%A0%90%ED%98%95-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%9F%AC)
