---  
layout: post
title: "[Python Cleancode] 4. SOLID"
subtitle: "[Python Cleancode] 4" 
categories: Python
tags: Cleancode
comments: true  
--- 

이번 장에서는 솔리드 원칙이라는 것을 검토하고 이를 파이썬스러운 방식으로 구현하는 방법을 설명한다. SOLID는 다음을 뜻한다. 

S : 단일 책임 원칙
O : 개방/폐쇄의 원칙
L : 리스코프 치환 원칙
I : 인터페이스 분리 원칙
D : 의존성 역전 원칙

## 단일 책임 원칙(Single Responsibility Principle)
- 컴포넌트는 단 하나의 책임을 져야 함. 
- 필요한 일 이상의 것을 하거나 너무 많은 것을 알고 있는 객체를 `신(god)`객체라 부른다.
  - 서로 다른 행동을 그룹화한 것으로 유지보수가 어려워진다. 
- 클래스에 있는 프로퍼티와 속성이 항상 메서드를 통해서 사용되도록 하는 것. 
  - 이들은 관련된 개념이기 때문에 동일한 추상화로 묶는 것이 가능하다. 
- 관계형 데이터베이스 설계에서의 정규화 개념과 유사. 
- 클래스의 메서드는 상호 배타적이며 서로 관련이 없어야 한다. 
  
#### 너무 많은 책임을 가진 클래스

```python
def load_activity(self):
    """소스에서 처리할 이벤트를 가져오기"""

def identify_events(self):
    """가져온 데이터를 파싱하여 도메인 객체 이벤트로 변환"""

def stream_events(self):
    """파싱한 이벤트를 외부 에이전트로 전송"""
```

- 이 클랙스의 문제점은 독립적인 동작을 하는 메서드를 하나의 인터페이스에 정의했다는 것. 
- 데이터를 표현하는 방식이라던가, 어떤 작업이 수정되면 클래스 전체적으로 변경되는 구조임. 
- **클래스가 손상되기 쉽고 유지보수가 어렵다**
- 외부 요소에 의한 영향을 최소화하고 싶을 떄 해결책은 보다 작고 응집력있는 추상화를 하는것.

#### 책임 분산
```python
class AlertSystem:

 def run(self):
   """SystemMonitor의 indentify_events() 호출"""
   """ActivityReader의 load() 호출"""
   """Output의 stream() 호출"""
   
class SystemMonitior:
   def identify_events(self):
   """가져온 데이터를 파싱하여 도메인 객체 이벤트로 전환"""

class ActivityReader:
   def load(self):
   """소스에서 처리할 이벤트 가져오기"""
class Output:
   def stream(self):
   """파싱한 이벤트를 외부 에이전트로 전송"""
```

- 솔루션을 보다 관라하기 쉽게 하기 위해 모든 메서드를 다른 클래스로 분리하여 **단일 책임**을 갖게 하자.(위 코드처럼)
- 각자의 책임을 가진 여러 객체로 만들고 이들 객체들과 협력하여 동일한 기능을 수행하는 객체를 만들 수 있다. 
- 이때 각각의 객체들은 특정한 기능을 캡슐화하여 나머지 객체들에 영향을 미치지 않으며 명확하고 구체적인 의미를 갖는다.
- 각자의 기능을 수정해도 다른 변경사항이 발생하지 않는다. 
- 새로운 클래스는 유지보수뿐 아니라 재사용이 쉬운 인터페이스를 정의한다.
  - 필요한 메소드만 상속 받기 때문
- 그러나 각 클래스가 딱 하나의 메서드를 가져야 한다는 것을 뜻하는 것은 아니다. 처리해야할 로직이 같으면 같은 클래스에 여러 메소드를 추가할 수 있다. 
  
## 개방/폐쇄 원칙(Open/Close Principal - OCP)

#### OCP란?

- 모듈이 개방되어 있으면서도 폐쇄되어야 한다는 원칙
- **클래스를 디자인할 때는 유지보수가 쉽도록 로직을 캡슐화하여 확장에는 개방되고 수정에는 폐쇄되도록 해야 한다.**
  - 확장 가능하고 새로운 요구사항이나 도메인 변화에 잘 적응하는 코드를 작성해야 한다는 뜻.
  - 새로운 기능을 추가하다가 기존 코드를 수정했다면 기존 로직이 잘못 디자인되었다는 뜻

#### 개방/폐쇄 원칙을 따르지 않을 경우 유지보수의 어려움

```python
class Event:
 def __init(self, raw_data):
   self.raw_data = raw_data
   
class UnknownEvent(Event):
 """데이터만으로 식별할 수 없는 이벤트"""
 
class LoginEvent(Event):
 """로그인 사용자에 의한 이벤트"""
 
class LogoutEvent(Event):
 """로그아웃 사용자에 의한 이벤트"""
 
 
class SystemMonitor:
 """시스템에서 발생한 이벤트 분류"""
 def __init__(self, event_data):
   self.event_data = event_data
 def identify_event(self):
   if(
    ...
  ):
   return LoginEvent(self.event_data)
  elif(
  ...
  ):
   return LogoutEvent(self.event_data)
   
  return UnKownEvent(self.event_data)
```

- elif 명령문 체인은 가독성 측면에서 최악
- 이벤트 유형을 결정하는 논리가 일체형으로 중앙 집중화되어있다. 
  - 지원하려는 이벤트가 늘어날수록 메서드도 커진다. 
- 수정을 위해 닫히지 않았다. 
  - 새로운 유형의 이벤트를 시스템에 추가할 때마다 메서드를 수정해야 한다.
- 메서드를 변경하지 않고도 새로운 유형의 이벤트를 추가하고 싶다(`폐쇄성`)
- 새로운 이벤트가 추가될때 이미 존재하는 코드를 변경하디 않고 코드를 확장하여 새로운 유형의 이벤트를 지원하고 싶다.(`개방원칙`)
- `메서드 입장`에서는 변경되지 않아야하고(`폐쇄성`) `새로운 이벤트 입장`에서는 수월하게 지원이 되어야 함(`개방원칙`)

#### 확장성을 가진 이벤트 시스템으로 리팩토링

- 이전 예제의 문제점은 SystemMonitor 클래스가 분류하려는 구체 클래스와 직접 상호 작용한다는 점. 
- 개방/폐쇄 원칙을 따르는 디자인을 달성하려면 추상화를 해야한다. 
- **대안은 SystemMonitor클래스를 추상적인 이벤트와 협력하도록 변경, 이벤트에 대응하는 개별 로직은 각 이벤트 클래스에 위임**
- 그 다음 각각의 이벤트에 다형성을 가진 새로운 메서드를 추가: meets_condition(event_data.dict)
```python
class Event:
 def __init(self, raw_data):
   self.raw_data = raw_data
   
 @staticmethod
 def meets_condition(event_data:dict):
   return False

class UnknownEvent(Event):
 """데이터만으로 식별할 수 없는 이벤트"""
 
class LoginEvent(Event):
 @staticmethod
 def meets_condition(event_data:dict):
   return(
  ...
  )
 
 
class LogoutEvent(Event):
 """로그아웃 사용자에 의한 이벤트"""
 @staticmethod
 def meets_condition(event_data:dict):
   return(
  ...
  )
 
class SystemMonitor:
 """시스템에서 발생한 이벤트 분류"""
 def __init__(self, event_data):
   self.event_data = event_data
 def identify_event(self):
   """이벤트 분류"""
   for event_cls in Event.__subclasses__():
     try:
       if event_cls.meets_condition(self.event_data):
         return event_cls(self.event_data)
     except KeyError:
       continue
       
   return UnKownEvent(self.event_data)
```

- 이 경우 transaction event가 추가될 때 새로운 클래스를 추가하는 것만으로 기존 코드가 예상한대로 잘 동작한다. (`개방성`)
- SystemMonitor.identify_event() 메서드는 전혀 수정하지 않았다. (`폐쇄성`)

#### OCP 최종 정리
- `다형성`이란?
  - 같은 모양의 코드가 다른 동작을 하는 것
  - 다형성은 코드의 양을 줄이고, 여러 객체 타입을 하나의 타입으로 관리가 가능하여 유지보수에 좋음

- 다형성의 효과적인 사용과 밀접하게 관련
- **다형성을 따르는 형태의 계약을 만들고 모델을 쉽게 확장할 수 있는 일반적인 구조로 디자인하는 것**
- OCP는 SW엔지니어링의 중요한 문제인 유지보수성에 대한 문제를 해결
- 코드를 변경하지 않고 기능을 확장하기 위해서는 보호하려는 추상화에 대해서 적절한 폐쇄를 해야함
- 단, 일부 추상화의 경우 충돌이 발생할 수 있으므로 항상 해당 원칙이 적용가능한 것은 아님

## 리스코프 치환 원칙(LSP)

- 리스코프 치환 원칙은 설계 시 안정성을 유지하기 위해 객체 타입이 유지해야 하는 일련의 특정을 말한다. 
- LSP의 주된 생각은 어떤 클래스에서든 클라이언트는 특별한 주의를 기울이지 않고도 하위 타입을 사용할 수 있어야 한다는 것. 
- 자식 클래스를 구현하는 개발자가 기존 프로그램이 문제없이 안정적으로 작동할 수 있도록 가이드라인을 알려주는 원칙
- 만약 S가 T의 하위타입이라면 프로그램을 변경하지 않고 T 타입의 객체를 S 타입의 객체로 치환 가능해야 함. 
- 정사각형 클래스가 직사각형 클래스를 상속한다고 하다. (S: 정사각형, T: 직사각형)
  - 정사각형의 특징인 네 변의 길이는 동일하다와 그렇지 않은 직사각형의 차이가 존재함. 
  - 이로 인해 직사각형을(T) 정사각형(S) 클래스로 치환해서 사용할 때, 네 변의 길이에 대한 두 클래스의 차이 떄문에 기존 프로그램이 오작동 할 수 있다. 
  - [python 코드](https://github.com/venomouscyanide/liskov/tree/master/Example%202)
- 결론적으로 하위 클래스는 상위 클래스에서 정의한 계약을 따르도록 디자인해야 된다는 뜻. 

#### 도구를 사용해 LSP 문제 검사하기

- 1장에서 소개한 MyPy나 Pylint같은 도구를 사용해 쉽게 검출할 수 있음
- 호환되지 않는 방식으로 메소드를 재정의하면 Mypy는 어노테이션을 검사하여 이를 확인
  - 파생클래스가 부모 클래스에서 정의한 파라미터와 다른 타입을 사용
  - 반환 값이 다른 타입일 경우
  - 메서드의 서명 자체가 완전히 다른 경우

#### 애매한 LSP 위반 사례
- 어떤 경우는 `LSP`를 위반한 것이 명확하지 않아서 자동화된 도구로 검사하기 애매할 수 있다. -> 코드리뷰를 통해 검사
- `DbC`(3장)에서의 계약은(사전조건, 사후조건) 하위 클래스에서도 항상 유지되어야 한다. 더 엄격해서도, 느슨해서도 안된다. 
 
#### LSP 최종 정리
- `LSP`는 객체지향 소프트웨어 설계의 핵심이 되는 다형성을 강조하기 때문에 좋은 디자인의 기초가 된다. 
- 인터페이스의 메소드가 올바른 계층구조를 갖도록 하여 상속된 클래스가 부모 클래스와 다형성을 유지하도록 하는 것. 
- LSP에서 제안하는 방식으로 신중하게 클래스를 디자인하면 계층을 올바르게 확장하는데 도움이 됨. 즉 `LSP`가 `OCP`에 기여

## 인터페이스 분리 원칙(Interdace Segregation Principle, ISP)

- 인터페이스란 객체가 노출하는 메서드의 집합
- 파이썬에서 인터페이스는 클래스 메서드의 형태를 보고 암시적으로 정의된다. (파이썬이 `duck typing`을 따르기 때문)
- `duck typing`이란?
  -  동적 타이핑의 한 종류로, 객체의 변수 및 메소드의 집합이 객체의 타입을 결정하는 것을 말한다. 
  -  클래스 상속이나 인터페이스 구현으로 타입을 구분하는 대신, `duck typing`은 객체가 어떤 타입에 걸맞은 변수와 메소드를 지니면 객체를 해당 타입에 속하는 것으로 간주
-  객체의 본질을 정의하는 것은 궁극적으로 메서드의 형태
-  파이썬 3 이후로는 인터페이스를 다른 방식으로 정의하는 `추상 기본 클래스 개념`이 도입됨
    -  파생 클래스가 구현해야 할 일부분을 기본 동작 또는 인터페이스로 정의하는 것
    - `가상 하위 클래스`라는 타입을 계층 구조에 등록하는 기법이 포함됨
    - 오리의 기준을 추가하여 덕타이핑의 개념을 조금 더 확장 하는 것
- `ISP`란 **다중 메서드를 가진 인터페이스가 있다면 매우 정확하고 구체적인 구분에 따라 더 적은 수의 메서드를 가진 여러개의 메서드로 분할하는 것이 좋다는 것**
- 재사용성을 높이기 위해 가능한 작은 단위로 인터페이스를 분리한다면 응집력이 높아짐. 
- 단일 책임 원칙이랑 뭐가 다르지?
  
#### 너무 많은 일을 하는 인터페이스

- XML과 JSON 포맷의 데이터를 파싱하는 경우 추상 기본 클래스를 만들고 `from_xml()`과 `from_json()`이라는 메서드를 정의하면 됨. 
- 그러나 어떤 클래스는 XML 메서드를 필요하지 않고 JSON 만으로 구성될 수 있다면 필요하지 않은 `from_xml()`을 제공하게 됨. 
- 이것은 결합력을 매우 높여 유연성이 떨어진다. 

#### 인터페이스는 작을수록 좋다. 

- 앞의 인터페이스는 각각 하나의 메서드를 가진 두 개의 다른 인터페이스로 분리하는 것이 좋다. 
- SRP와 유사하지만 주요 차이점은 ISP는 인터페이스에 대해 이야기한다는 점. 

#### 인터페이스는 얼마나 작아야할까?

- 극단적으로 받아들이면 안됨. 딱 한가지 메서드만 있어야 한다는 뜻은 아님. 
- 컨텍스트 관리자는 반드시 `__enter__`와 `__exit__` 두가지 메서드가 필요하기에 반드시 함께 제공되어야 함. 


## 의존성 역전(DIP)

- 코드가 깨지거나 손상되는 취약점으로부터 보호해주는 흥미로운 디자인 원칙을 제시한다. 
- 의존성을 역전시킨다는 것은 코드가 세부 사항이나 구체적인 구현에 적응하도록 하지 않고 대신에 API같은 것에 적응하도록 하는 것
- A와 B객체가 상호교류를 함
    - A가 B의 인스턴스를 사용하지만 B모듈을 직접 관리하지는 않음
    - 만약 B코드가 변경되면 원래의 코드는 쉽게 깨짐
    - **이를 방지하기 위해서는 의존성을 거꾸로 뒤집어서 역전시켜야 함.**
    - 즉 B가 A에 적응하게 해야함. 
- 의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것 보다는 변화하기 어려운 것에 의존하라는 원칙
- 변화하기 어려운 것 : 정책 전략과 같은 어떤 큰 흐름이나 개념 같은 추상적인 것, 추상 클래스와 인터페이스
- 변하하기 쉬운 것: 구체적인 방식, 사물 등과 같은 것, 구체 클래스
  
#### 엄격한 의존의 예
- 식별된 이벤트를 데이터 수집기로 전달한다고 하자. 
- 이벤트 식별 클래스(Evnetstramer) -> 이벤트 전송 클래스(Syslog) ->  이
- 그러나 이것은 저수준의 내용에 따라 고수준의 클래스가 변경되어야 함. (Syslog로 데이터를 보내는 방식이 변경되면 EventStramer를 수정해야함)

#### 의존성을 거꾸로
- EventStramer를 구체 클래스가 아닌 인터페이스와 대화하도록
- 이벤트 식별 클래스(Evnetstramer) -> 데이터 전송 대상(DataTargetClient) -> 이벤트 전송 클래스(Syslog) 
- 데이터의 구체적인 구현과 관련이 없어짐. 구현 내용이 바뀌어도 수정할 필요가 없다. 
- 의존성을 동적으로 제공한다고 하여 **의존성 주입** 이라고 함. 
-