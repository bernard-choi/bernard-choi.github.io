---
layout: post
title: "[운영체제] 프로세스간 커뮤니케이션"
subtitle: "[운영체제] 프로세스간 커뮤니케이션"
categories: CS
tags: OS  
comments: true


---

## 프로세스간 커뮤니케이션

- `IPC`(Inter Process Communication)
- 프로세스들이 서로의 공간을 쉽게 접근할 수 있다면 프로세스 데이터/코드가 바뀔 수 있으니 프로세스는 다른 프로세스의 공간을 접근할 수 없다. 
- 그러나, 성능을 높이기 위해 여러 프로세스를 만들어서 동시 실행(CPU core 8~16개에서 동시에 실행 후 모아서 작업하기)하려면 프로세스간 상태 확인 및 데이터 송수신이 필요하다. 

## 프로세스간 커뮤니케이션이 필요한 이유

- fork() 시스템콜
  - 본인과 똑같은 프로세스를 하나 더 생성. 원본이 부모이고 생성된것이 자식이다. 
  - 프로세스를 fork()해서 여러 프로세스를 동시에 실행시킬 수 있다.(병렬 처리)

- 1~10000까지 더하기
  - fork() 함수로 10개 프로세스 만들어가 각각 1~1000 1001~2000 더하기
  - 각각 더한 값을 모두 합하면 더 빠르게 동작 가능
  - 각 프로세스가 더한 값을 수집해야 하므로 프로세스간 통신 필요

-  웹서버
  - 웹서버의 경우 얼마나 빠르게 응답을 하는지가 성능의 지표
  - 1개의 CPU 면 응답이 매우 느리기 때문에 각각의 요청이 각각의 CPU에서 프로세스를 만들어서 빨리 응답해주는게 빠르다. 
  - 변화량을 각 CPU끼리 주고 받아야 한다. 

## 파일을 사용한 커뮤니케이션도 가능하지 않을까?

- 프로세스간 직접적인 코드 전달은 안되지만 저장 공간은 공유한다. (shared.txt(file))
- 간단히 다른 프로세스에 전달할 내용을 파일에 쓰고 다른 프로세스가 해당 파일을 읽으면 된다. 
- file을 사용하면 실시간으로 직접 원하는 프로세스에 데이터 전달이 어렵다. 
  - 실시간 데이터를 받기 위해서는 계속 읽어야 하는데 비효율적임. 
- 대부분의 `IPC`기법은 결국 커널 공간을 활용한다. 
  - 커널 공간은 프로세스끼리 공유하기 때문이다. 


## 실제 프로세스

- 하나의 프로세스는 4GB
- 3 ~ 4GB 는 운영체제 코드가 들어가는 공간. (1GB가 커널공간)
- 0 ~ 3GB가 프로그램이 사용하는 공간
- 사용자 모드에서는 커널 공간 접근 불가
- 전체 공간중 일부만 실제 메모리에 존재하게됨
- 커널 공간은 물리 메모리 하나에서 공유하게됨. (프로세스 A, B의 운영체제 코드들이 공유가 됨.)

## IPC 기법

### 1. Message Queue
- FIFO 정책으로 데이터 전송
- A 프로세스
```
//특별한 key를 부여해서 msqid라는 message 큐를 만든다.(id발급 받음)
msqid = msgget(key, msgflg) // key는 1234, msgflg는 옵션
//sbuf에다가 데이터를 넣어 놓고 보낸다.  
msgsnd(msqid, &sbuf, buf_length, IPC_NOWAIT) //send
```

- B 프로세스
```
//A프로세스와 같은 Queue ID를 발급 받는다.
msqid = msgget(key, msgflg) // key는 동일하게 1234로 해야 해당 큐의 msqid를 얻을 수 있음
//0으로 채워진 공간인 sbuf에 A에서 보낸 데이터를 받는다.
msgrcv(msqid, &sbuf, buf_length, MSGSZ, 1, 0) //receive
```

- 부모 자식 관계가 필요 없이, 어느 프로세스 간에라도 key값만 알면 주고 받을 수 있다. 
- queue는 2개 만들어서 각각 쓰면 쌍방향 통신도 가능. 

### 2. Pipe

```
char* msg = "Hello Child Process!";
int main() {
    char buf[255];
    int fd[2], pid, nbytes;
    //파이프가 정상적으로 생성이 되면 특정한 주소값을 fd에 두개 준다. 
    if (pipe(fd) < 0) // pipe(fd)로 파이프 생성
        exit(1);//정상적으로 작동하지 않으니 종료
    pid = fork(); //이 함수 실행 다음 코드부터 부모/자식 프로세스로 나뉘어짐
    if (pid > 0) { //부모 프로세스는 pid에 실제 프로세스 ID가 들어감
        //0이 아니면 부모다
        write(fd[1], msg, MSGSIZE); //fd[1]에 작성된 주소에 msg를 작성한다. 
        exit(0);
    }
    else {//자식 프로세느는 pid가 0이 들어감
        //0이다 == 자식이다
        nbytes = read(fd[0], buf, MSGSIZE); // buf공간에 MSGSIZE만큼 부모 데이터에 써진 
msg가 넘어온다 (통신이 된다!)
        printf("%d %s\n", nbytes, buf);
        exit(0);
    }
    return 0;
}

```

- 기본 `pipe`는 단방향 통신
- fork()로 자식 프로세스 만들었을 때, 부모와 자식간의 통신이 된다. (부모 -> 자식)
- 부모와 fd[0]과 자식의 fd[1]은 안씀
- `pipe`와 `message queue`
  - 둘다 먼저 넣은 데이터가 먼저 읽혀진다
  - `pipe`는 부모 자식관계이고 메시지큐는 부모자식 관계가 없다. 
  - `pipe`와 달리 `message queue`는 양방향 통신이 가능하다.
  - 메모리 공간도 kernel/user로 구분되고 pipe와 message 둘 다 kernel에서 이뤄진다. 

### 3. Shared memory(공유메모리)
- 노골적으로 kernel space에 메모리 공간을 만들고 해당 공간을 변수처럼 쓰는 방식
- FIFO 방식이 아니라 해당 메모리 주소를 마치 변수처럼 접근한다. 
- 공유메모리 key를 가지고 여러 프로세스가 접근 가능하다. 

### 4. 시그널(Signal)
- 유닉스에서 30년 이상 사용된 전통적인 기법
- 커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지를 알려주는 기법
- 프로세스 관련 코드에 관련 시그널 핸들러를 등록해서 해당 `시그널` 처리 실행
  - 각각의 `시그널`을 받으면 운영체제가 해야 하는 행동들이 정의되어 있음
  - 64개의 명령리스트가 있음
  - 시그널 무시
  - 시그널 블록(블록을 푸는 순간 프로세스에 해당 시그널 전달)
  - 등록된 시그널 핸들러가 특정 동작을 수행
  - 등록된 시그널 핸들러가 없다면, 커널에서 기본 동작 수행
    - SIGUSER1
    - SIGUSER2
    - 위의 2개의 시그널은 기본 동작이 정의되어 있지 않고 프로그램을 만들 때 특별 동작을 하도록 정의할 수 있다. 
  - PCB에 해당 프로세스가 블록 또는 처리해야 하는 시그널 관련 정보 관리
    - 사용자모드에서 커널로 가서 작업을 하고 다시 사용자로 돌아오려고 할 때 해당 프로세스 PCB signal을 확인 해서 signal처리가 필요하다면 커널함수를 호출 해서 실행한 다음 사용자모드로 돌아간다.(커널모드에서 사용자모드 전환 시 시그널 처리)
    - 특정 동작이 사용자 모드의 프로세스에 저장되어 있다면 사용자 모드로 돌아가면 작동 하도록 명령한다.

### 5. 소켓(socket)
- 네트워크 통신을 위한 기술
- 기본적으로는 클라이언트와 서버 등 두개의 다른 컴퓨터간의 네트워크 기반 통신을 위한 기술이다. (응답과 요청)
- 네트워크 기기를 사용하는 system call이라고 사용해도 된다. 
- 하나의 컴퓨터 안에서 두개의 프로세스간에 통신 기법으로 사용 가능
  - 커널 모드의 네트워크 기기에서 다른 프로세스로 전달을 하면 통신이 된다. 




<details>
<summary>한 프로세스가 다른 프로세스에 자원에 접근하는 방법은 무엇이 있나?</summary>
<div markdown="1">       

한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, inter-process communication)을 사용해야 한다. 파이프, 메시지큐, 공유메모리, 시그널등을 이용할 수 있다. 

</div>
</details>
