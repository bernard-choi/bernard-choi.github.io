---  
layout: post
title: "[Python Cleancode] 5. Decorator"
subtitle: "[Python Cleancode] 5 Decorator" 
categories: Python
tags: Cleancode
comments: true  
--- 

## 1. 파이썬의 데코레이터

- 함수에 변형을 할 때마다 modifier 함수를 사용하여 함수를 호출한 다음 함수를 처음 정의한 것과 같은 이름으로 재할당해야했음

```python
def original(...):

original = modifier(original)
```

- 이는 혼란스럽고 오류가 발생하기 쉬움

```python
@modifier
def original(...):
	...
```

- 데코레이터는 데코레이터 이후에 나오는 것을 데코레이터의 첫 번째 파라미터로 하고 데코레이터의 결과 값을 반환하게 하는 문법적 설탕
    - `syntax sugar` : 타이핑의 수고를 덜어주기 위해 또는 읽기 쉽게 하기 위해 다른 표현으로 코딩할 수 있게 해주는 기능

- 이 예제에서 말하는 modifier는 파이썬 용어로 `데코레이터`라 하고, original을 `래핑된 객체`라고 함.
- 원래는 함수와 메서드를 위해 고안되었지만 실제로는 어떤 종류의 객체에도 적용이 가능하기 때문에 여기서는 함수와 메서드, 제너레이터, 클래스에 데코레이터를 적용하는 방법을 살펴본다.
- 데코레이터와 데코레이터 디자인 패턴을 혼동하지 말자.
    - 데코레이터 패턴은 **객체의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주는 패턴**
    - 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 Decorator 클래스로 정의한 후 필요한 Decorator 객체를 조합하는 방식
- 데코레이터는 `Callable Object`를 넘겨 받아서 `Callable Object`를 반환하는 형태의 문법
    - 함수 뿐만 아니라 클래스도 Callable object면 Decorator를 사용 가능

파이썬 callable 객체가 9개인가 있음.  괄호가 붙을 수 있으면 call할 수 있다. 

__call__ 가 있어야 괄호를 붙일 수 있다. 

### 1. 1 함수 데코레이터

- 가장 간단한 방법은 함수에 적용하는 것.
- 예를 들어 다음과 같이 도메인의 특정 예외에 대해서 특정 횟수만큼 재시도하는 데코레이터를 만들어 볼 수 있다.
- 코드예시

    ```python
    class ControlledException(Exception):
        """A generic exception on the program's domain."""

    def retry(operation):
        @wraps(operation)
        def wrapped(*args, **kwargs):
            last_raised = None
            RETRIES_LIMIT = 3
            for _ in range(RETRIES_LIMIT):
                try:
                    return operation(*args, **kwargs)
                except ControlledException as e:
                    logger.info("retrying %s", operation.__qualname__)
                    last_raised = e
            raise last_raised

        return wrapped

    @retry
    def run_operation(task):
    	"""실행 중 예외가 발생할 것으로 예상되는 특정 작업을 실행"""
    	return task.run()
    ```

- @retry 는 실제로 파이썬에서 run_operation = retry(run_operation)을 실행하게 해주는 문법적 설탕
- timeout 같은 예외가 발생할 경우 여러 번 호출을 반복하는 retry 로직을 어떻게 데코레이터로 만들 수 있는지 살펴보았다.

### 1.2 클레스 데코레이터

- 함수에 적용한 것처럼 클래스에도 데코레이터를 사용할 수 있다. 유일한 차이점은 데코레이터 함수의 파라미터로 함수가 아닌 클래스를 받는다.
- 클래스 데코레이터가 가독성을 떨어뜨릴 수 있다. 왜냐하면, 클래스에서 정의한 속성과 메서드를 데코레이터 안에서 완전히 다른 용도로 변경할 수 있기 때문.

클래스 데코레이터의 장점

- 클래스 데코레이터는 코드 재사용과 DRY(dont repeat yourself) 원칙의 모든 이점을 공유.
    - 여러 클래스가 특정 인터페이스나 기준을 따르도록 강제할 수 있다.
- 당장은 작고 간단한 클래스를 생성하고 나중에 데코레이터로 기능을 보강할 수 있다.
- 어떤 클래스에 대해서는 유지보수 시 데코레이터를 사용해 로직을 훨씬 쉽게 변경할 수 있다. 메타클래스와 같은 방법은 권장하지 않는다.

메타클라스 클래스의 클래스, 로직이 변경될 수 있음. 데코레이터를 쓰는 방법을 권장. 

- 각 이벤트마다 직렬화 방법을 정의한 클래스를 만드는 경우
- serialize는 패스워드를 숨기고 timestamp 필드를 포매팅하는 기능이 들어있다.
- 코드예시

    ```python
    class LoginEventSerializer:
        def __init__(self, event):
            self.event = event

        def serialize(self) -> dict:
            return {
                "username": self.event.username,
                "password": "**redacted**",
                "ip": self.event.ip,
                "timestamp": self.event.timestamp.strftime("%Y-%m-%d %H:%M"),
            }

    class SignupSerializer:
    	
    class ~Serializer:

    class LoginEvent:
        SERIALIZER = LoginEventSerializer

        def __init__(self, username, password, ip, timestamp):
            self.username = username
            self.password = password
            self.ip = ip
            self.timestamp = timestamp

        def serialize(self) -> dict:
            return self.SERIALIZER(self).serialize()
    ```

이 방법은 처음에는 잘 동작하지만, 시간이 지나면서 시스템을 확장할수록 다음과 같은 문제가 발생

- **클래스가 너무 많아진다**: 이벤트 클래스와 직렬화 클래스가 1대1로 매핑되어 있으므로 직렬화 클래스가 점점 많아지게 된다.
    - ex) 로그인 이벤트가 아니라, 회원가입 이벤트이면 password를 암호화하면 안됨. 회원가입Serilizer를 따로 만들어줘야함...
- **이러한 방법은 충분히 유연하지 않다** : 만약 password를 가진 다른 클래스에서도 이 필드를 숨기려면 함수로 분리한 다음 여러 클래스에서 호출해야 한다. 이는 코드를 충분히 재사용했다고 볼 수가 없다.
- **표준화** : serialize() 메서드는 모든 이벤트 클래스에 있어야만 한다. 비록 믹스인을 사용해 다른 클래스로 분리할 수 있지만 상속을 제대로 사용했다고 볼 수 없다.
    - 모든 이벤트 클래스에 있어야 한다는 것 자체가 재사용성을 활용하지 못했다는 것?

또 다른 방법은 이벤트 인스턴스와 변형 함수를 필터로 받아서 동적으로 객체를 만드는 것. 

필터를 이벤트 인스턴스의 필드들에 적용해 직렬화하는 것. 

- 코드예시

    ```python
    def hide_field(field) -> str:
        return "**redacted**"

    def format_time(field_timestamp: datetime) -> str:
        return field_timestamp.strftime("%Y-%m-%d %H:%M")

    def show_original(event_field):
        return event_field

    class EventSerializer:
        """Apply the transformations to an Event object based on its properties and
        the definition of the function to apply to each field.
        """

        def __init__(self, serialization_fields: dict) -> None:
            """Created with a mapping of fields to functions.
            Example::
            >>> serialization_fields = {
            ...    "username": str.upper,
            ...    "name": str.title,
            ... }
            Means that then this object is called with::
            >>> from types import SimpleNamespace
            >>> event = SimpleNamespace(username="usr", name="name")
            >>> result = EventSerializer(serialization_fields).serialize(event)
            Will return a dictionary where::
            >>> result == {
            ...     "username": event.username.upper(),
            ...     "name": event.name.title(),
            ... }
            True
            """
            self.serialization_fields = serialization_fields

        def serialize(self, event) -> dict:
            """Get all the attributes from ``event``, apply the transformations to
            each attribute, and place it in a dictionary to be returned.
            """
            return {
                field: transformation(getattr(event, field))
                for field, transformation in self.serialization_fields.items()
            }

    class Serialization:
        """A class decorator created with transformation functions to be applied
        over the fields of the class instance.
        """

        def __init__(self, **transformations):
            """The ``transformations`` dictionary contains the definition of how to
            map the attributes of the instance of the class, at serialization time.
            """
            self.serializer = EventSerializer(transformations)

        def __call__(self, event_class):
            """Called when being applied to ``event_class``, will replace the
            ``serialize`` method of this one by a new version that uses the
            serializer instance.
            """

            def serialize_method(event_instance):
                return self.serializer.serialize(event_instance)

            event_class.serialize = serialize_method # serialize() 메서드 추가?
            return event_class

    @Serialization(
        username=str.lower,
        password=hide_field,
        ip=show_original,
        timestamp=format_time,
    )

    @Serialzation(

    )

    class LoginEvent:
        def __init__(self, username, password, ip, timestamp):
            self.username = username
            self.password = password
            self.ip = ip
            self.timestamp = timestamp

    ```

- 데코레이터를 사용하면 다른 클래스의 코드를 확인하지 않고도 각 필드가 어떻게 처리되는지 쉽게 알 수 있다.

### 1.3 다른 유형의 데코레이터

- 데코레이터가 단지 함수나 메서드 클래스에만 적용되지 않는다.
- 제너레이터나 코루틴 심지어 어미 데코레이트된 객체도 데코레이트가 가능(스택 형태로 쌓일 수 있다)
- 또 다른 좋은 사용 예는 코루틴으로 사용되는 제너레이터
    - 주 아이디어는 새로 생성된 제너레이터에 데이터를 보내기 전에 next()를 호출하여 yield문으로 넘어가야 하는데 이러한 수작업은 사용자기 기억해야 하는 것으로 에러를 유발하기 쉽다
    - 제너레이터를 파라미터로 받아 next()를 호출한 다음 다시 제너레이터를 반환하는 데코레이터를 만들자.

제너레이터가 값을 받기 위한 목적으로도 쓰인다. 

### 1.4 데코레이터에 인자 전달

- 파라미터를 갖는 데코레이터를 구현하는 방법
    - 첫번째, 간접참조(indirection)을 통해 새로운 레벨의 중첩 함수를 만들어 데코레이터의 모든 것을 한단계 깊게 만드는것
    - 두번째, 데코레이터를 위한 클래스를 만드는것
- 두번째 방법이 가독성이 더 좋다.
- 보통 두가지 방법 모두 살펴보고 상황에 알맞게 결정을 내리면 됨

## 중첩함수의 데코레이터

- 데코레이터는 함수를 파라미터로 받아서 함수를 반환하는 함수. 이런 함수를 `고차 함수`라고 부른다.
- 데코레이터를 파라미터에 전달하려면 다른 수준의 간접 참조가 필요.
    - 첫번째 함수는 파라미터를 받아서 내부 함수에 전달
    - 두번째 함수는 데코레이터가 될 함수
    - 세번째는 데코레이팅의 결과를 반환하는 함수
    - 즉, 최소 세 단계의 중첩 함수가 필요

- 코드예시

    ```python
    RETRIES_LIMIT = 3

    def with_retry(retries_limit=RETRIES_LIMIT, allowed_exceptions=None):
        allowed_exceptions = allowed_exceptions or (ControlledException,)

        def retry(operation):
            @wraps(operation)
            def wrapped(*args, **kwargs):
                last_raised = None
                for _ in range(retries_limit):
                    try:
                        return operation(*args, **kwargs)
                    except allowed_exceptions as e:
                        logger.warning(
                            "retrying %s due to %s", operation.__qualname__, e
                        )
                        last_raised = e
                raise last_raised

            return wrapped

        return retry

    @with_retry()
    def run_operation(task):
        return task.run()

    @with_retry(retries_limit=5)
    def run_with_custom_retries_limit(task):
        return task.run()

    @with_retry(allowed_exceptions=(AttributeError,))
    def run_with_custom_exceptions(task):
        return task.run()

    @with_retry(
        retries_limit=4, allowed_exceptions=(ZeroDivisionError, AttributeError)
    )
    def run_with_custom_parameters(task):
        return task.run()
    ```

## 데코레이터 객체

- 앞의 예제에서는 세단계의 중첩된 함수가 필요.
- 이것보다 깔끔하게 구현하기 위해 클래스를 사용하여 데코레이터를 정의할 수 있음
- 파이썬 구문이 어떻게 처리되는지 이해하는 것이 중요
    - 먼저 @ 연산 전에 전달된 파라미터를 사용해 데코레이터 객체를 생성(__new__)
        - 클래스를 호출 시 인스턴스가 리턴됨
    - 데코레이터 객체는 __init__ 메서드에서 정해진 로직에 따라 초기화를 진행
    - 그 다음, @ 연산이 호출
- 코드예시

    ```python
    RETRIES_LIMIT = 3

    class WithRetry:
        def __init__(self, retries_limit=RETRIES_LIMIT, allowed_exceptions=None):
            self.retries_limit = retries_limit
            self.allowed_exceptions = allowed_exceptions or (ControlledException,)

        def __call__(self, operation):
            @wraps(operation)
            def wrapped(*args, **kwargs):
                last_raised = None

                for _ in range(self.retries_limit):
                    try:
                        return operation(*args, **kwargs)
                    except self.allowed_exceptions as e:
                        logger.info(
                            "retrying %s due to %s", operation.__qualname__, e
                        )
                        last_raised = e
                raise last_raised

            return wrapped

    @WithRetry()
    def run_operation(task):
        return task.run()

    @WithRetry(retries_limit=5)
    def run_with_custom_retries_limit(task):
        return task.run()

    @WithRetry(allowed_exceptions=(AttributeError,))
    def run_with_custom_exceptions(task):
        return task.run()

    @WithRetry(
        retries_limit=4, allowed_exceptions=(ZeroDivisionError, AttributeError)
    )
    def run_with_custom_parameters(task):
        return task.run()
    ```

### 데코레이터 활용 우수 사례

- 데코레이터가 사용되는 예제는 수 없이 많지만 가장 관련성이 높은 몇가지를 소개하면
    - 파라미터 변환

        더 멋진 API를 노출하기 위해 함수의 서명을 변경하는 경우. 이때 파라미터가 어떻게 처리되고 변환되는지를 캡슐화하여 숨길 수 있다. 

    - 코드 추적

        파라미터와 함께 함수의 실행을 로깅하려는 경우. 

        - 실제 함수의 실행 경로 추적
        - 함수 지표 모니터링(CPU, 메모리)
        - 함수의 실행 시간 측정
        - 언제 함수가 실행되고 전달된 파라미터는 무엇인지 로깅
    - 파라미터 유효성 검사
    - 재시도 로직 구현
    - 일부 반복 작업을 데코레이터로 이동하여 클래스 단순화

## 2. 데코레이터의 활용 - 흔한 실수 피하기

### 2.1 래핑된 원본 객체의 데이터 보존.

- 원본 함수의 일부 프로퍼티나 또는 속성을 유지하지 않아 원하지 않는 부작용을 유발
- 데코레이터는 원래 함수의 어떤 것도 변경하지 않아야 하지만 코드에 결함이 있어서 이름이나 docstring을 변경하는 경우가 있다.
    - **데코레이터가 실제로 원본 함수를 wrapped라 불리는 새로운 함수**로 변경했기 때문에 원본 함수의 이름이 아닌 새로운 함수의 이름을 출력
    - 만약 이 데코레이터를 이름이 다른 여러 함수에 적용하더라도 결국은 wrapped라는 이름만 출력.
    - 이렇게 되면 개별 함수를 확인하고 싶은 경우에 실제 실행된 함수를 알 수 없으므로 오히려 디버깅이 더 어려워짐.
- 코드 예시

    ```python
    def wrapped(*args, **kwargs):
            logger.info("running %s", function.__qualname__)
            return function(*args, **kwargs)

        return wrapped

    @trace_decorator
    def process_account(account_id):
        """Process an account by Id."""
        logger.info("processing account %s", account_id)
        ...

    >>> help(process_account)
    Help on function weapped in module decorator_wraps_1:

    wrapped(*args, **kwargs)

    >>> print(process_account.__qnalname__)
    'trace_decorator.<locals>.wrapped'
    ```

- 또 다른 문제는 이러한 함수에 테스트와 함께 docstring을 작성한 경우 데코레이터에 의해 덮어써진다는점.
    - doctest 모듈로 코드를 호출해소 테스트가 있는 docstring은 실행되지 않는다.

- 래핑된 함수 즉 wrapped 함수에 @wraps 데코레이터를 적용 하여 **실제로는 function 파라미터 함수를 래핑한 것이라고 알려주는 것**
- 코드 예시

    ```python
    def trace_decorator(function):
        """Log when a function is being called."""

        @wraps(function)
        def wrapped(*args, **kwargs):
            logger.info("running %s", function.__qualname__)
            return function(*args, **kwargs)

        return wrapped

    @trace_decorator
    def process_account(account_id):
        """Process an account by Id."""
        logger.info("processing account %s", account_id)
        ...

    >>> help(process_account)
    id별 계정처리

    >>> print(process_account.__qnalname__)
    'process account'
    ```

    - 일반적인 데코레이터의 경우 아래와 같은 구조에 따라 functools.wraps를 추가하면 된다.
    - 코드예시

### 2.2 데코레이터 부작용 처리

- 데코레이터 함수가 되기 위해 필요한 하나의 조건은 **가장 안쪽에 정의된 함수**여야 한다. 그렇지 않으면 임포트에 문제가 발생함.
- 그럼에도 불구하고 때로는 임포트 시에 실행하기 위해 이러한 부작용이 필요한 경우도 있고 반대의 경우도 있다.

## 데코레이터 부작용의 잘못된 처리

- 코드예시

    ```python
    def traced_function_wrong(function):
        """An example of a badly defined decorator."""
        logger.debug("started execution of %s", function)
        start_time = time.time()

        @wraps(function)
        def wrapped(*args, **kwargs):
            result = function(*args, **kwargs)
            logger.info(
                "function %s took %.2fs", function, time.time() - start_time
            )
            return result

        return wrapped

    @traced_function_wrong
    def process_with_delay(callback, delay=0):
        logger.info("sleep(%d)", delay)
        return callback
    ```

- 함수를 임포트 했는데 로그가 남음

```python
>>> from decorator_side_effects_1 import process_with_delay
INFO:<function process_with_delay at 0x...> 함수 실행 
```

- 함수를 실행할 경우 동일한 기능인데 실행할 때마다 오래 걸림

```python
>>>main()
INFO:함수 <function process_with_delay at 0x>의 실행시간: 8.67s
>>>main()
INFO:함수 <function process_with_delay at 0x>의 실행시간: 13.67s
>>>main()
INFO:함수 <function process_with_delay at 0x>의 실행시간: 17.67s
```

- 함수에 설정된 start_time은 모듈을 처음 임포트할 때의 시간. 래핑된 함수 내부로 코드를 이동
- 코드예시

    ```python
    def traced_function(function):
        @wraps(function)
        def wrapped(*args, **kwargs):
            logger.info("started execution of %s", function)
            start_time = time.time()
            result = function(*args, **kwargs)
            logger.info(
                "function %s took %.2fs", function, time.time() - start_time
            )
            return result

        return wrapped

    @traced_function
    def call_with_delay(callback, delay=0):
        logger.info("sleep(%d)", delay)
        return callback
    ```

## 데코레이터 부작용의 활용

- 때로는 이러한 부작용을 의도적으로 사용하여 실제 실행이 가능한 시점까지 기다리지 않는 경우도 있다.
- 대표적인 예로, **모듈의 공용 레지스트리에 객체를 등록하는 경우**
- 예를 들어, 이전 이벤트 시스템에서 일부 이벤트만 사용하려는 경우
    - 이 경우 이벤트 계층 구조의 중간에 가상의 클래스를 만들고 일부 파생 클래스에 대해서만 이벤트를 처리하도록 할 수 있다.
    - 각 클래스마다 처리 여부에 플래그(flag) 표시를 하는 대신에 데코레이터를 사용해 명시적으로 표시를 할 수 있다.

- 사용자와 관련된 모든 이벤트 클래스가 있다. 여기서는 `LoginEvent`와 `UserLogoutEvent`만 처리
- Registry는 비어있는 것처럼 보이지만 이 모듈의 일부를 임포트하면 register_event 데코레이터로 지정한 클래스로 채워지게 된다.
- flask router decorator → import 할때
- 코드예시

    ```python
    EVENTS_REGISTRY = {}

    def register_event(event_cls):
        """Place the class for the event into the registry to make it accessible in
        the module.
        """
        EVENTS_REGISTRY[event_cls.__name__] = event_cls
        return event_cls

    class Event:
        """A base event object"""

    class UserEvent:
        TYPE = "user"

    @register_event
    class UserLoginEvent(UserEvent):
        """Represents the event of a user when it has just accessed the system."""

    @register_event
    class UserLogoutEvent(UserEvent):
        """Event triggered right after a user abandoned the system."""

    >>> from decorator_side_effects_2 import EVENTS_REGISTRY
    >>> EVENTS_REGISTRY
    {'UserLoginEvent': decorator_side_effects_2.UserLoginEvent,
     'UserLogoutEvent': decorator_side_effects_2.UserLogoutEvent
    ```

- EVENT_REGISTRY는 런타임중에 모듈을 임포트한 직후에야 최종 값을 가지므로 코드만 봐서는 어떤 값이 될 지 쉽게 예측하기 어렵다.
- 많은 웹 프레임워크나 널리 알려진 라이브러리들은 이 원리로 객체를 노출하거나 활용한다.
- 결과 객체를 외부에 노출하는 코드가 있어야 한다.

### 2.3 어느 곳에서나 동작하는 데코레이터 만들기

- *args, **kwargs 서명을 사용하여 데코레이터를 정의하면 모든 경우에 사용할 수 있다.
- 그러나 다음 두 가지 이유로 원래 함수의 서명과 비슷하게  데코레이터를 정의하는 것이 좋을 때가 있다.
    - 원래의 함수와 모양이 비슷하기 때문에 읽기가 쉽다
    - 파라미터를 받아서 뭔가를 하려면 *args와 **kwargs 를 사용하는 것이 좋다.

- 파라미터를 받아서 특정 객체를 생성하는 경우가 많다고 생각해보자. 예를 들어, 문자열을 받아서 빈번히 드라이버 객체를 초기화하는 경우.
- 이런 경우 데코레이터를 만들어서 중복을 제거할 수 있다.
- DBDriver 객체는 연결 문자열을 받아서 데이터베이스에 연결하고 DB 연산을 수행하는 객체.
- 데코레이터는 이러한 변환을 자동화하여 문자열을 받아 DBDriver를 생성하고 함수에 전달.
- 따라서 마치 객체를 직접 받은 것처럼 가정할 수 있다.
- 코드 예시

    ```python
    class DBDriver:
        def __init__(self, dbstring):
            self.dbstring = dbstring

        def execute(self, query):
            return f"query {query} at {self.dbstring}"

    def inject_db_driver(function):
        """This decorator converts the parameter by creating a ``DBDriver``
        instance from the database dsn string.
        """

        @wraps(function)
        def wrapped(dbstring):
            return function(DBDriver(dbstring))

        return wrapped

    @inject_db_driver
    def run_query(driver):
        return driver.execute("test_function")

    >>> run_query("test_OK")
    'test_OK 에서 쿼리 test_function 실행'

    class DataHandler:
        @inject_db_driver
        def run_query(self, driver):
            return driver.execute("test_method")

    >> DataHandler().run_query("test_fails")
    Traceback(most recent call last):

    TypeError: wrapped() takes 1 positional argument but 2 were given
    ```

- 클래스의 메서드에는 self라는 추가 변수가 있다
- 메서드는 자신이 정의된 객체를 나타내는 self라는 특수한 변수를 항상 첫 번째 파라미터로 받도록 되어 있다.
- 따라서 하나의 파라미터만 받도록 설계된 이 데코레이터는 연결 문자열 자리에 self를 전달하고 두 번째 파라미터에는 아무것도 전달하지 않아서 에러가 발생
- 이 문제를 해결하려면 **메서드와 함수에 대해서 동일하게 동작하는 데코레이터를 만들어야함**.
- 디스크립터 프로토콜을 구현한 데코레이터 객체를 만든다.
- 코드 예시

    ```python
    class DBDriver:
        def __init__(self, dbstring):
            self.dbstring = dbstring

        def execute(self, query):
            return f"query {query} at {self.dbstring}"

    class inject_db_driver:
        """Convert a string to a DBDriver instance and pass this to the wrapped
        function.
        """

        def __init__(self, function):
            self.function = function
            wraps(self.function)(self)

        def __call__(self, dbstring):
            return self.function(DBDriver(dbstring))

        def __get__(self, instance, owner):
            if instance is None:
                return self
            return self.__class__(MethodType(self.function, instance))

    @inject_db_driver
    def run_query(driver):
        return driver.execute("test_function_2")

    class DataHandler:
        @inject_db_driver
        def run_query(self, driver):
            return driver.execute("test_method_2")
    ```

## 3. 데코레이터와 DRY 원칙

- 데코레이터의 가장 큰 장점은 여러 객체에 데코레이터를 적용하여 코드를 재사용할 수 있다는 것
- DRY(Don't Repeat Yourself)원칙을 잘 따른다.
- 신중하게 설계되지 않은 데코레이터는 코드의 복잡성을 증가시킨다
- 그다지 재사용할 필요가 없을 경우 별개의 함수나 작은 클래스로도 충분
- 기존 코드를 데코레이터로 리팩토링할지 결정하는 기준은?
    - GLASS01  → 컴포넌트가 충분히 재사용 가능한 추상화를 했다고 인정받기 위해서는 적어도 3가지 이상의 어플리케이션에서 시험해봐야 한다는 것.
- 결론은 다음과 같은 사항을 고려했을 경우만 데코레이터 사용을 권한다는 것
    - 처음부터 데코레이터를 만들지 않는다. 패턴이 생기고 데코레이터에 대한 추상화가 명확해지면 그 때 리팩토링을 한다.
    - 데코레이터가 적어도 3회 이상 필요한 경우에만 구현
    - 데코레이터 코드를 최소한으로 유지

## 4. 데코레이터와 관심사의 분리

- 데코레이터에 하나 이상의 책임을 두면 안된다.  SRP는 데코레이터에도 적용

## 5. 좋은 데코레이터 분석

- 캡슐화와 관심사의 분리

    좋은 데코레이터는 실제로 하는 일과 데코레이팅하는 일의 책임을 명확히 구분해야 한다. 어설프게 추상화를 하면 안 된다. 즉 데코레이터의 클라이언트는 내부에서 어떻게 구현했는지 전혀 알 수 없는 블랙박스 모드로 동작해야 한다. 

- 독립성

    데코레이터가 하는 일은 독립적이어야 하며 데코레이팅되는 객체와 최대한 분리되어야 한다. 

- 재사용성

    데코레이터는 하나의 함수 인스턴스에만 적용되는 것이 아니라 여러 유형에 적용 가능한 형태가 바람직하다. 왜냐하면 하나의 함수에만 적용된다면 데코레이터가 아니라 함수로 대신할 수도 있기 때문이다. 충분이 범용적이어야 한다. 

- Celery 가 decorator의 좋은 예
- 함수 본문을 정의하기만 하면 데코레이터가 이를 자동으로 작업으로 변환
- 반면 사용자는 데코레이터가 하는일을 알지 못한다(캡슐화)