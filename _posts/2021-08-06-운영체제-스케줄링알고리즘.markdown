---
layout: post
title: "[운영체제] 프로세스 스케줄링"
subtitle: "[운영체제] 프로세스 스케줄링"
categories: CS
tags: OS  
comments: true


---

## 프로세스 스케줄링이란?
---

- 프로세스 스케줄러는 **멀티 프로그래밍** 과 **시분할(time sharing)**의 목적을 달성하기 위해 실행 가능한 여러 프로세스 중에서 하나의 프로세스를 선택해 실행한다. 
- 각 CPU 코어는 한번에 한 프로세스를 실행할 수 있다. 
- 따라서 단일 CPU 코어 시스템에 반해 멀티 코어 시스템은 한 번에 여러 프로세스를 실행 할 수 있다. 

- **멀티프로그래밍**
  - CPU 사용률을 최대화하기 위해 항상 프로세스를 실행하도록 한다. 어떤 프로세스가 CPU를 사용하다가 I/O 작업 등 CPU를 필요로 하지 않는 순간이 오면 다른 프로세스가 CPU를 사용할 수 있도록 한다. 
- **시분할**
  - 각 프로그램이 실행되는 동안 사용자들이 상호작용할 수 있도록 프로세스 간 CPU 코어를 자주 전환하는 것. CPU가 하나의 프로그램를 수행하는 시간을 매우 짧은 시간(ms)으로 제한하여 프로그램을 번갈아 수행하도록 하면 CPU가 하나인 환경에서도 여러 사용자가 동시에 사용하는 듯한 효과를 가져올 수 있다.

## 프로세스 상태
---

![process-state-diagram](https://yunsikus.github.io/assets/img/post_img/process-state-diagram.jpg)

- **New** : 프로세스가 생성됨
- **Running** : 프로세스의 Instruction이 실행됨
- **Waiting** : (I/O 작업 완료나 신호 수신과 같은) 이벤트가 발생하기를 기다림
- **Ready** : 프로세서에 할당되기를 기다림
- **Terminated** : 프로세스가 실행을 끝냄

## 스케줄링 큐
---

**Ready Queue**
- 프로세스가 시스템에 들어오면 ready queue에 들어가서 CPU코어에서 실행되기를 기다린다. 
- Linked List 형태로 저장되며, ready queue의 header는 list의 첫번째 PCN를 가리키고, 각 PCB의 포인터는 ready queue에 있는 다음 PCB를 가리킨다. 

**Wait Queue**
- I/O 요청과 같은 특정 이벤트가 처리 완료되기까지를 기다리는 프로세스가 wait queue에 배치된다.
- 프로세스는 waiting 상태에서 ready 상태로 바뀌면 ready queue에 들어가게 된다.

![process-state-diagram](https://yunsikus.github.io/assets/img/post_img/queueing-diagram1.jpg)

프로세스는 종료될 떄까지 위의 Queueing-diagram과 같은 주기를 반복하고, 종료되면 모든 큐에서 제거되고 PCB 및 자원할당이 해제됨

## CPU 스케줄링
--- 

**FIFO 스케줄러(First in First Out)**
- 특징 
    - 먼저 온 고객을 먼저 서비스해주는 방식. 먼저 온 순서대로 차리
    - 가장 간단한 스케줄러(배치처리시스템)
    - FCFS(First Come First Served)
    - 비선점형 스케줄링
      - 일단 CPU를 잡으면 CPU burst가 완료될 때까지CPU를 반환하지 않는다. 할당되었던 CPU가 반환될때만 스케줄링이 이루어짐
- 문제점
    - 실행시간 큰 프로세스로 다른 프로세스들이 딜레이가 생길 수 있음

**최단 작업 우선 (Shortest Job First) 스케줄러**
- 특징
  - 가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행을 시키는 알고리즘
  - 다른 프로세스가 먼저 도착했어도 CPU burst time이 짧은 프로세스에게 선 할당
  - FIFO와 마찬가지로 비선점형 스케줄링
  - 응답시간이 짧지만 수행기산을 다 알아야함
- 문제점
  - 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안된다. 이 스케줄링은 극단적으로 CPU 사용이 짧은 job을 선호. 그래서 사용이 긴 프로세스는 거의 영원한 CPU를 할당받을 수 없다. 

**SRT(Shortest Remaining time First)**
- 특징
  - 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다
  - 선점형 스케줄링
    - 현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 뺏긴다
- 문제점
  - 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다. 

**Priority Scheduling**
- 특징
  - 우선순위가 가장 높은 프로세스에게 CPU를 할당 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다. 
  - 선점형 스케줄링 방식
    - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점
  - 비선점형 스케줄링 방식
    - 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 Head에 넣는다
- 문제점
  - 실행 준비는 되어있으나 CPU를 사용 못하는 프로세스를 CPU가 무기한 대기하는 상태. 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주어 해결 가능
    
**Round Robin**
- 특징
  - 현대적인 CPU 스케줄링. 시분할 시스템을 위해 설계됨
  - 각 프로세스는 동일한 크기의 할당 시간(time quantun)을 갖게 된다. 
  - 할당 시간이 지나면 프로세스는 선점 당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다
  - `RR`은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
  - `RR`이 가능한 이유는 프로세스의 context를 save할 수 있기 때문
- 장점
  - Response time이 빨라진다. 
    - n개의 프로세스가 ready queue에 있고 할당시간이 q(time quantun)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
  - 프로세스가 기다리는 시간이 CPU를 사용할 만큼 증가한다. 
    - 공정한 스케줄링이라고 할 수 있다. 
- 주의할 점
  - 설정한 `time quantum`이 너무 커지면 FCFS와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch로 overhead가 발생한다. 그렇기 때문에 적당한 `time quantun`을 설정하는 것이 중요


<details>
<summary>질문 1 스케줄링이 필요한 이유?</summary>
<div markdown="1">       

한정적인 메모리(자원)를 효율적으로 관리하기 위해, 공정성을 주기 위해 필요하다.

</div>
</details>


<details>
<summary>질문 2 스케줄러와 CPU 스케줄러의 차이에 대하여 설명해보세요.</summary>
<div markdown="1">       

스케줄러(=Job Scehduler, 장기 스케줄러)는 디스크와 메모리 간 스케줄링을 담당한다.

CPU 스케쥴러(= 단기 스케줄러)는 메모리와 CPU 간 스케줄링을 담당한다.

</div>
</details>


<details>
<summary>질문 3 FCFS 스케줄링을 개선한 스케줄링 방식에 대하여 설명해보세요..</summary>
<div markdown="1">       

FCFS는 먼저 도착한 프로세스에게 CPU를 할당하는 기법이다.

하지만 먼저 도착한 프로세스가 실행 시간이 긴 경우 나중에 도착한 프로세스들의 대기 시간이 길어지는 Convoy Effect 라는 문제점을 가지고 있다.

이를 개선한 SJF(Shortest Job First) 기법이 있다.

SJF는 짧은 실행시간을 갖는 프로세스에게 CPU를 먼저 할당하는 기법이다.

Convoy Effect는 해결하였지만, 실행시간이 긴 프로세스는 계속 CPU를 할당받지 못하는 Starvation 현상이 일어날 수 있다.

</div>
</details>


<details>
<summary>질문 5 Round Robin 스케줄링 방식에서 time quantum 설정에 따른 결과를 설명해보세요.</summary>
<div markdown="1">       

타임퀀텀이 긴 경우: 타임퀀텀이 프로세스의 실행시간과 비슷해진다면 FCFS랑 다를 바 없어진다.

타임퀀텀이 짧은 경우: 타임퀀텀이 짧아 Context Switching이 자주 일어나게 되어 오버헤드가 발생한다.

</div>
</details>

<details>
<summary>질문 6 오버헤드가 어떤건가요?.</summary>
<div markdown="1">       

프로그램의 실행 흐름 도중에 동떨어진 위치의 코드를 실행시켜야 할 때, 추가적으로 시간, 메모리, 자원이 사용되는 현상을 오버헤드라 한다.

</div>
</details>

<details>
<summary>질문 7 다음 스케줄링 알고리즘을 설명하시오 - FCFS.</summary>
<div markdown="1">       
- 특징 
    - 먼저 온 고객을 먼저 서비스해주는 방식. 먼저 온 순서대로 차리
    - 가장 간단한 스케줄러(배치처리시스템)
    - FCFS(First Come First Served)
    - 비선점형 스케줄링
      - 일단 CPU를 잡으면 CPU burst가 완료될 때까지CPU를 반환하지 않는다. 할당되었던 CPU가 반환될때만 스케줄링이 이루어짐
- 문제점
    - 실행시간 큰 프로세스로 다른 프로세스들이 딜레이가 생길 수 있음
</div>
</details>


<details>
<summary>질문 8 다음 스케줄링 알고리즘을 설명하시오 - SJF.</summary>
<div markdown="1">       
- 특징
  - 가장 프로세스 실행시간이 짧은 프로세스부터 먼저 실행을 시키는 알고리즘
  - 다른 프로세스가 먼저 도착했어도 CPU burst time이 짧은 프로세스에게 선 할당
  - FIFO와 마찬가지로 비선점형 스케줄링
  - 응답시간이 짧지만 수행기산을 다 알아야함
- 문제점
  - 효율성을 추구하는게 가장 중요하지만 특정 프로세스가 지나치게 차별받으면 안된다. 이 스케줄링은 극단적으로 CPU 사용이 짧은 job을 선호. 그래서 사용이 긴 프로세스는 거의 영원한 CPU를 할당받을 수 없다. 
</div>
</details>

<details>
<summary>질문 8 다음 스케줄링 알고리즘을 설명하시오 - SRT.</summary>
<div markdown="1">       
- 특징
  - 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다
  - 선점형 스케줄링
    - 현재 수행중인 프로세스의 남은 burst time보다 더 짧은 CPU burst time을 가지는 새로운 프로세스가 도착하면 CPU를 뺏긴다
- 문제점
  - 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다. 
</div>
</details>

<details>
<summary>질문 9 다음 스케줄링 알고리즘을 설명하시오 - Priority Scheduling.</summary>
<div markdown="1">       
- 특징
  - 우선순위가 가장 높은 프로세스에게 CPU를 할당 우선순위란 정수로 표현하게 되고 작은 숫자가 우선순위가 높다. 
  - 선점형 스케줄링 방식
    - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점
  - 비선점형 스케줄링 방식
    - 더 높은 우선순위의 프로세스가 도착하면 Ready Queue의 Head에 넣는다
- 문제점
  - 실행 준비는 되어있으나 CPU를 사용 못하는 프로세스를 CPU가 무기한 대기하는 상태. 아무리 우선순위가 낮은 프로세스라도 오래 기다리면 우선순위를 높여주어 해결 가능

</div>
</details>

<details>
<summary>질문 10 다음 스케줄링 알고리즘을 설명하시오 - Round Robin.</summary>
<div markdown="1">       
- 특징
  - 현대적인 CPU 스케줄링. 시분할 시스템을 위해 설계됨
  - 각 프로세스는 동일한 크기의 할당 시간(time quantun)을 갖게 된다. 
  - 할당 시간이 지나면 프로세스는 선점 당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다
  - `RR`은 CPU 사용시간이 랜덤한 프로세스들이 섞여있을 경우에 효율적
  - `RR`이 가능한 이유는 프로세스의 context를 save할 수 있기 때문
- 장점
  - Response time이 빨라진다. 
    - n개의 프로세스가 ready queue에 있고 할당시간이 q(time quantun)인 경우 각 프로세스는 q 단위로 CPU 시간의 1/n을 얻는다. 즉, 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.
  - 프로세스가 기다리는 시간이 CPU를 사용할 만큼 증가한다. 
    - 공정한 스케줄링이라고 할 수 있다. 
- 주의할 점
  - 설정한 `time quantum`이 너무 커지면 FCFS와 같아진다. 또 너무 작아지면 스케줄링 알고리즘의 목적에는 이상적이지만 잦은 context switch로 overhead가 발생한다. 그렇기 때문에 적당한 `time quantun`을 설정하는 것이 중요
</div>
</details>

## Reference
[RR Scheduling 유투브](https://www.youtube.com/watch?v=ce6TPD3-98Q)


