---  
layout: post
title: "[Python Cleancode] 3. 좋은 코드의 일반적인 특징"
subtitle: "[Python Cleancode] 3" 
categories: Python
tags: Cleancode
comments: true  
--- 

## 1. 계약에 의한 디자인(DbC)

- **코드가 정상적으로 동작하기 위해 기대하는 것과 호출자가 반환 받기를 기대하는 것은 디자인의 하나가 되어야 한다**. 여기서 계약이라는 개념이 생긴다.

- 계약에 의한 디자인이란 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 한 다음 계약을 어겼을 경우는 명시적으로 왜 계속할 수 없는지 예러를 발생시키라는 것. 

- 계약은 주로 `사전조건`과 `사후조건`을 명시, 때로는 `불변식`과 `부작용`을 기술

#### 1.1 사전조건과 사후조건

**사전조건**
- **함수나 메서드가 제대로 동작하기 위해 보장해야 하는 모든 것.**
- 쉽게 말해, 함수에 올바른 데이터를 전달하는 것. 초기화된 객체, null이 아닌 값 등이 조건이 된다. 
- 유효성 검사는 mypy의 타입체킹 뿐만 아니라 필요로 하는 값이 정확한지 확인하는 것.  
- **클라이언트에서 함수 호출 전에 할지(관용적 접근법), 함수가 자체적으로 로직을 실행하기 전에 할 지 선택해야 법(까다로운 접근법)**
- 일반적으로 업계에서는 견고한 스프트웨어를 위해 후자를 택함. 즉 입력에 대해 신뢰하지 않기 때문에 함수 자체적으로 확인

  
**사후조건**

- **사전조건과 반대로 여기서는 함수 변환 값의 유효성 검사 수행 후 상태를 강제하는 것**
- 호출자가 이 컴포넌트에서 기대한 것을 제대로 받았는지 확인하기 위해 수행
- 이러한 작업은 컴포넌트(로직을 처리하는 함수나 메서드)에게 부과된 임무

**불변식**
함수가 실행되는 동안 일정하게 유지되는 것. 로직이 문제가 없는 것인가
loop environmet에서 매 반복문이 어떤 불변 조건을 가지느냐. 
pep316 -> docstring 등 inv로 되어있는게 불변식을 작성한것. 
self state는 이 다섯가지 중에 하나여야 된다. 등등

**부작용**
말 그대로

scikit learn 검사할 때 decorator를 붙인다. 

호출된 함수 (demanding)
함수 입장에서 생각을 해야한다. 
API로 문서로 빠질수도 있고 어떤 일련의 커뮤니케이션을 통합해서 의미할 수도 있다. 

단위, 함수까지 내려가서 테스트를 한다. -> 교과서적인 얘기


#### 1.2 계약에 의한 디자인을 하는 이유

- 이렇게 하면 책임소재를 신속하게 파악할 수 있다. 
- 사전조건 검증에 실패하면 클라이언트의 결함. 반대로 사후조건은 컴포넌트와 연관되어 있음 

---

## 2. 방어적 프로그래밍

- DbC와는 달리 계약이라는 것을 전제하지 않는다. 
- 객체나 함수 또는 메서드와 같은 코드의 모든 부분을 **유효하지 않은 것으로부터 스스로 보호하도록 하는것**.
- 주요 예상할 수 있는 주제는 2가지
  -  시나리오의 오류를 처리하는 방법(에러핸들링)
  -  발생하지 않아야 하는 오류를 처리하는 방법(Assertion)

#### 2.1 에러 핸들링

- 에러 핸들링의 주요 목적은 다음을 결정하는것
  - 예상되는 에러에 대해서 실행을 계속할 수 있을지 
  - 아니면 극복할 수 없는 오류여서 프로그램을 중단할지를 결정하는 것
  
- 에러 처리 방법은 `값 대체`, `에러 로깅`, `예외 처리`가 있음

#### 값 대체

- 잘못된 값을 생성하거나 프로그램 전체가 종료될 위험이 있을 경우 결과 값을 안전한 값으로 대체(기본값, 잘 알려진 상수, 초기 값)
- 오류가 있는 값을 유사한 값으로 대체하는 것은 더 위험하며 오류를 숨겨버릴 수 있다는 사실을 유의
  
#### 예외처리

- 에러 발생 시 호출자에게 오류에 대해 알려주고 실행을 멈춘다. 단 예외처리가 많아지면 프로그램의 흐름을 읽기 어려워 진다는 단점이 있다. 
- 올바른 수준의 추상화 단계에서 예외처리
  - 예외를 발생시키거나 처리할 떄 이 예외를 이 클래스가 발생시키는게 맞는지, 또 이 클래스에서 처리하는게 맞는지등을 고려해야 한다. 
  - ConnectionError는 connect 메서드 내에서 처리
- Traceback 노출 금지
  - 파이썬에서 traceback은 매우 유용하고 많은 디버깅 정보를 포함하기 때문에 보안상 사용자에게 보여지면 안됨
- 비어있는 except 블록 지양(너무 방어적이면 코드는 문제를 숨기고 유지보수를 더 어렵게 만든다)
- ex) 파이썬 장고에서 dubugging 모드를 True를 주면 traceback을 다 웹 페이지 수준에서 보여줌


```python
try:
    process_data()
except:
    pass
```
    - 에러는 결코 조용히 전달되어서는 안된다는 파이썬의 철학을 떠올리면 파이썬스러운 코드가 아니다
    - 보다 구체적인 예외를 사용(AttributeError 등)
    - 각 예외에 대해서 except 처리
- 원본 예외 포함(오류처리 과정에서 다른 오류를 발생)
  - 오류 처리 과정에서 다른 오류를 발생시키고 메시지를 변겨할 수 있다. 이 경우 원래 예외를 포함하는 것이 좋다. 
  - 만약 파이썬에서 제공하는 기본 예외를 사용자 정의 예외로 래핑하고 싶다면, 루트 예외에 대한 정보를 `raise ... from ...` 구문을 사용하여 같이 포함할 수 있다. 

```python
class InternalDataError(Exception):
    """ 사용자 정의 예외"""
    pass

def process(data_dictionary, record_id):
    try:
        return data_dictonary[record_id]
    except KeyError as e:
        raise InternalDataError("Record not present") from e
```
#### 2.2 파이썬에서 어설션 사용하기

- 어설션은 절대로 일어나지 않아야 하는 상황에 사용되므로 assert 문에 사용된 표현식은 항상 참이여야 함
- 즉 어설션 조건은 프로그램의 실행조건을 설명 
- 에러 핸들링과 다르게 어설션 조건 판별이 False인 경우 AseertionError을 발생시키고 프로그램을 중지시킨다. 
- 이 AssertionError를 try except로 처리하는 것은 옳지 않다. 이 에러가 발생한다는 것은 애초에 프로그램 어딘가에 결함이 있다는 의미

---

## 3. 관심사의 분리

- 책임이 다르면 컴포넌트, 계층 또는 모듈로 분리되어야 한다.
- 프로그램의 각 부분은 기능의 일부분(관심사)에 대해서만 책임을 지며 나머지 부분에 대해서는 알 필요가 없다.  
- **파급효과를 최소화하여 유지보수성을 향상시킬 수 있다.**
- 유지보수를 위한 코드를 생각할때 `결합력`을 낮추고 `응집도`는 높여야 한다.  

#### 응집력
- 컴포넌트는 잘 정의된 한가지의 목적을 가져야 하며
- 가능하면 작아야 한다는 것을 의미한다. 
- 응집력이 높을 수록 재사용성은 높아진다. 

#### 결합력
- 두 개 이상의 객체가 서로 어떻게 의존하는지를 나타낸다. 
- 결합력이 높으면 다음과 같은 문제를 일으킨다. 
  - 낮은 재사용성 : 특정 객체에 지나치게 의존하는 경우 함수를 사용하기가 어렵다. 
  - 파급효과 : 두 부분 중 하나를 변경하면 다른 부분에도 영향을 미친다. 
  - 낮은 수준의 추상화 : 두 함수가 너무 가깝게 관련되어 있으면 서로 다른 추상화 레벨에서 문제를 해결하기 어렵다. 

---

## 4. 개발 지침 약어
- 좋은 소프트웨어 관행을 약어를 통해 쉽게 기억하자
  
#### DRY/OAOO

- Do not repeat yourself, 
- Once and noly once
- 중복을 피하자. 코드에 있는 지식은 단 한번, 단 한 곳에 정의되어야 한다. 
  
#### YAGNI
-  You Ain't Gonna Need it
-  오직 현재의 요구사항을 잘 해결하기 위한 소프트웨어를 작성
-  내가 짜고 있는 코드가 일어나지도 않을 밀의 일을 예상하고 코드를 더 복잡하게 만들고 있는 건 아닌지
-  즉 지금 필요하지도 않은 오버 엔지니어링을 하고 있는 건 아닌지 염두해야 한다.

#### KIS
-  Keep it Simple
-  YAGNI 원칙과 비슷하다. 디자인이 단순할수록 유지 관리가 쉽다. 
-  모든 확장 가능성, 좀 더 일반화적인 추상화가 지금 기능 개발 시점에서는 섣부를 수 있다. 
-  코드 측면의 단순함이란 문제에 맞는 가장 작은 데이터 구조를 사용하는 것을 의미
- 과잉 엔지니어링을 하지 않기. 굳이 필요 없는 추가 개발 하지 않기


#### EAFP / LBYL

- Easier to Ask Forgiveness than Permission
- Look Before You Leap
- EAFP는 일단 코드를 실행하고 실제 동작하지 않을 경우 대응. 파이써닉한 철학
- LBYL는 도약하기 전에 무엇을 사용하려는지 확인

---

## 5. 컴포지션과 상속

#### 5.1 상속이 좋은 선택인 경우
- 파생 클래스를 만드는 것은 양날의 검이 될 수 있다.
  - 장점: 부모 클래스를 공짜로 전수 받을 수 있다
  - 단점: 새로운 정의에 너무 많은 기능을 추가하게 될 수 있다. 만약 대부분의 메서드를 필요로 하지 않고 재정의하거나 대채해야 한다면 설계상의 실수 
  
- 다음과 같은 경우 상속의 좋은 선택의 예
  - 클래스의 기능을 그대로 물려받으면서 충분히 사용할 상황이 있고, 추가 기능을 더하거나 기능을 수정하는 경우
  - 인터페이스용 클래스를 정의하고, 이를 하위 클래스에서 상속받아 기능을 강제하려는 경우
  - 다형성을 통해 로직을 유연하게 설계하려는 경우(Exception을 상속받아 예외를 처리하는 경우가 대표적인 예)
- **상속이 좋은 일반적인 경우를 한 단어로 표현하면 "전문화"**. 즉 상속을 통하여 기본 객첼에서 출발하여 세부적인 추상화를 할 수 있다. 

#### **컴포지션** 이란?
-  상속과 다르게 단순히 사용한다는 개념. 
-  즉 기존의 상속 개념에서의 자식 클래스가 부모클래스의 모든 속성을 물려받는게 아니라, 자식 클래스가 필요한 속성만 부모클래스로부터 가져와 사용하는것. 
-  이 방법은 개념적으로 정확할 뿐만 아니라 확장성도 뛰어나다. 결합력을 줄이고 파급효과를 최소화하며 보다 나은 리팩토링을 허용.

일반적으로 상속은 암시적 선언, 컴포지션은 명시적 선언이라고 한다. 

#### 5.2 상속 안티 패턴

Bad Case

```python
class TransactionPolicy(collections.UserDict):
    """잘못된 상속의 예"""
    
    def change_in_policy(self, customer_id, **new_policy_data):
        self[customer_id].update(**new_policy_date)
```

이 코드는 `UserDict`를 상속받아, 도메인에 맞는 구체적인 `Dict` 형태의 클래스를 정의했다. 
위 코드는 2가지의 문제가 있다. 

1. TransactionPolicy 이름만 보고 어떻게 사전 타입인지 알 수 있을까?
2. UserDict에 있는 수많은 메서드가 이 클래스에 실제로 필요할까?

단지 첨자 기능을 얻기 우해 사전을 확장하는 것은 충분한 근거가 되지 않는다. 사전 자료형에 대해서 개념적으로 확장되거나 세부적이라는 것이라고는 생각 할 수 없다. 

Good Case

- 상속이 아닌 해결책은 바로 컴포지션을 이용하는 것

```python
class TransactionPolicy:
    """컴포지션을 통한 해결 예"""

    def __init__(self, policy_data, **extra_data):
        self._data = {**policy_data, **extra_data}  # Dict 의 기능을 _data 에 위임한다.

    def change_in_policy(self, customer_id, **new_policy_data):
        self._data[customer_id].update(**new_policy_data)

    # __getitem__ 과 __len__ 을 구현함으로써 Dict 의 첨자 기능을 이용할 수 있도록 한다.
    def __getitem__(self, customer_id):
        return self._data[customer_id]

    def __len__(self):
        return len(self._data)
```
- 이전의 예시와 달리 NewTransactionPolicy 클래스 에서는 사전 자료형을 상속받지 않았다. 
- 하지만 __init__ 함수에서 _data를 private로 선언하면서 사전자료형의 데이터로 초기화한다.
-  그리고 이후 우리가 사용하고자 하는 change_in_policy함수와 __getitem__함수에서 _data, 즉 사전 자료형을 활용하여 구현하고자 하는 기능을 구현하였다.



#### 5.3 파이썬의 다중 상속

- 파이썬은 다중 상속을 지원. 올바르게 구현되지 않으면 문제가 커질 수 있음. 

**메서드 결정 순서(MRO)**
- 파이썬에서는 다중 상속이 발샹할 때, 상속 순서가 앞쪽에 있는 부모 클래스의 메서드를 사용. 
  
```python
class A:
    name = "class A"
    def __init__(self):
        print("class A init")

class B:
    name = "class B"
    def __init__(self):
        print("class B init")

class C(A, B):
    def __init__(self):
        super().__init__()
```

```python
C.name # class A
C() # class A init
```

#### Mixin
- 믹스인은 특별한 종류의 다중상속
- 보통은 다른 클래스와 함쎄 믹스인을 다중 상속하여 믹스인에 있는 메서드나 상속을 사용
- 믹스인의 포인트는 상속을 통해 다른 유형에 "혼합"할 수 있는 유형을 생성하는 것
- **상속에 영향을 주지 않으면서 해당 유형에 유익한 기능을 제공하는 것**
  
```python
Class BaseTokenizer:
    def __init__(self, str_token):
        self.str_token = str_token

    def __iter__(self):
        yield from self.str_token.split("-")

tk = BaseTokenizer("282a3n-djs34-sds234")
list(tk) # ["282a3n,djs34, sds234"]

Class UpperIterableMixin:
    def __iter__(self):
        return map(str.upper, super().__iter__())

Class Tokenizer(UpperIterableMixin, BaseTokenizer):
    pass

tk = Tokenizer():
list(tk) # ["28A3N,DJS34, SDS234"]
```

---

## 6. 함수와 메서드의 인자

#### 6.1 파이썬의 함수 인자 동작 방식
파이썬에서는 함수에 인자가 넘어온 경우 기본적으로 "참조" 형태로 가져온다. 
다만, 이 함수 내에서 인자의 값이 바뀔 경우 이 인자가 가변형(mutable)이나 불변형(immutable)이냐에 따라 그 결과가 달라진다. 

인자가 가변형(mutable)인 경우
- 함수 내에서 값을 수정하면 그대로 참조 객체에 수정된다. id도 동일

```python
def func(a):
    print(f"함수 내에서 값 할당 전 id : {id(a)}")
    a += "4"
    print(f"함수 내에서 값 할당 후 id : {id(a)}")

mutable = [1, 2, 3]
print(f"함수 호출 전 id : {id(mutable)}")
func(mutable)
print(f"함수 호출 후 id : {id(mutable)}")
print(mutable)
```

```python
# 결과
함수 호출 전 id : 4424245064
함수 내에서 값 할당 전 id : 4424245064
함수 내에서 값 할당 후 id : 4424245064
함수 호출 후 id : 4424245064
[1, 2, 3, '4']
```
인자가 불변형(immutable)일 경우

```python
def func(a):
    print(f"함수 내에서 값 할당 전 id : {id(a)}")
    a += "4"
    print(f"함수 내에서 값 할당 후 id : {id(a)}")

immutable = "1 2 3"
print(f"함수 호출 전 id : {id(immutable)}")
func(immutable)
print(f"함수 호출 후 id : {id(immutable)}")
print(immutable)
```

```python
def func(a):
    print(f"함수 내에서 값 할당 전 id : {id(a)}")
    a += "4"
    print(f"함수 내에서 값 할당 후 id : {id(a)}")

immutable = "1 2 3"
print(f"함수 호출 전 id : {id(immutable)}")
func(immutable)
print(f"함수 호출 후 id : {id(immutable)}")
print(immutable)
```

#### 6.2 함수 인자의 개수
- 함수 인자는 적을수록 좋다. 함수 인자가 많을수록 호출자와 밀첩하게 결합된다. 
```python
def func(a, b, c, d, e, f, g, h, i, j, k):
    pas
```

- 호출자가 이 함수를 사용하여면 a부터 k까지 모두 필요하다. 
- 
해결방법 1. 전달하는 모든 인자를 포함하는 새로운 객체를 만드는것

```python
def func(class_param):
    pass
```

- a ~ k를 포함하는 객체 class_param을 전달함으로써 함수 인자 개수가 줄어든다. 
- 다만 이렇게 객체 자체가 넘어가는 경우 함수 내부에 사용되지 않는 정보까지 같이 넘어갈 수가 있다. 
- 따라서 애초에 객체를 올바르게 추상화하여 이런 오버헤드를 막을 필요가 있다. 

해결방법 2. 가변 인자나 키워드 인자를 사용하여 동적 서명

```python
def func(*args, **kwargs):
    pass
```

- 매우 동적이어서 유지 보수하기가 어렵다. 
- kwargs에 어떤 변수가 담겨오는지 코드 자체에 명시되지 않기 때문에 이 함수를 설계하는 사람은 이 정보를 코드 외적으로 알아야됨


## Question
1. 예외처리를 무조건 한번에 묶어서 처리하는 것이 좋은가?
   
- 한번에 한가지 일을 하는게 응집력이 높아 선호되지만 case by case 인거 같다. 예를 들어, 딕셔너리의 키에러와 리스트의 인덱스에러는 같은 부모 에러를 가지므로 하나의 에러인것 처럼 처리 가능하다. 이런 경우에는 굳이 나눠서 처리할 필요는 없는 듯.  

2. Assertion 도 결국은 예외처리인데 어떤 경우에 Asserion을 사용하고 어떤 경우는 예외처리를 하는지?
3. 
- database 접속 정보나 django settings 파일이 없는 경우와 같이 절대 피해야 되는 상황에서 assertion을 사용하는 경우를 보았다. assertion은 중요도가 높은 상황(절대 발생해서는 안되는 상황)에서 하나의 약속으로 보면 될듯. 

3. 불변식이란?
   
- 함수가 실행되는 동안 일정하게 유지되는 것. 로직이 문제가 없는 것인가
loop environmet에서 매 반복문이 어떤 불변 조건을 가지느냐. 
pep316 -> docstring 등 inv로 되어있는게 불변식을 작성한것. 
self state는 이 다섯가지 중에 하나여야 된다. 등등

- 불변식에 대해서 문서화(docstring) 하는 것이 좋다.
- 함수가 실행되는 동안 일정하게 유지되는 것으로, 함수의 로직에 문제가 없는지 확인 하기 위한 것
- 예시가 없나?
    - [https://velog.io/@muchogusto/불변식](https://velog.io/@muchogusto/%EB%B6%88%EB%B3%80%EC%8B%9D)
    - [https://velog.io/@hytenic/Python-Python-Clean-code-좋은-코드의-일반적인-특징](https://velog.io/@hytenic/Python-Python-Clean-code-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EC%9D%98-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9D%B8-%ED%8A%B9%EC%A7%95)
    - (불변식 예. while문의 isRunning과 같은 해당 함수가 작동하는 동안 유지되는 것)
    - [https://www.python.org/dev/peps/pep-0316/](https://www.python.org/dev/peps/pep-0316/)


개발지침
코드 스타일
파이썬스러운 방식, 코드리뷰할때도 
if try 뭐가 빨라. 

실제 생활에서는 고민하게 된다. 
Yagni
a
b 기능을 고
개발하는 사람도 기획의 능력이 있어야 함. 기획이 확정적이기가 힘들다. 
지향한다. 

상속 컴포지션이랑 
객체지형 iser(같은건지) haser(갖는건지)

상속받는 클래스의 public 메소드는 부모 클래스가 정의하는 public 메소드와 일치
-> overiding할 때

88p overiding 예시

basetokenizer


jwttokenizer -> 상속
기능만 분리해서 사용할 수 있다. 

upper 
super() upper의 부모를 가르키지 않는다. mro에 존재하는 하위를 가르킨다. 다중상속 super()가 어떻게 작동하는가를 이해하는게 중요하다. 다중상속을 받았을 떄 왼쪽에 있는것만 아니라, 다른 클래스에 있는 것들도 쓰고 싶다. 

super() 함수 어떻게 동작하는가. 우선순위에서 떨어짐는걸 super함수로 할수가 있다. 

동일한 방식으로 작동

call by value(파이썬에서는 없다)
파이썬에서는 변수가 없다. 객체에 대한 이름만 있다. 메모리에 변수공간을 만들지는 않는다. 주소를 넘기는 방식
call by reference 

a = [1, 2, 3, 4] # mutable
b = '1234' # immutable

그냥 프린트는 객체 주소를 넘긴다. 객체 그뿐로 넘겨와서 새로운 값을 넘긴것 뿐

키워드 가변인자 패러미터 가변